---
title: Java
tags: Notes Computer-Science Java
article_header:
  type: 
  image:
    src: 
---

Java Learning Notes

<!--more-->


# Java Terminology


JVM - Java virtual machine


JRE - Java runtime environment (includes JVM and supporting libraries)


javac - java compiler (takes .java and produces .class)


java - command to run the JVM


JDK - Java development kit (JRE, javac and supporting tools)


bytecode - compiled from source by the javac and interpreted by the JVM jar file - a zip file containing .class files (and some metadata)


JIT - just-in-time compiling; turning bytecode into machine code


JNI - Java native interface - allows native code and Java to interoperate


javadoc - parses source code comments and generates documentation


J2EE - Java 2 Enterprise Edition - set of libraries to assist in creating client/server architectures (EJBs/etc) Avoid at all costs


J2SE - Java 2 Standard Edition - a.k.a. JDK. Just say JDK


JCP - Java community process (jcp.org) - place to add new features into Java


JSR - Java specification request - request to JCP to add a new feature


# Procedural Java


## Primitives


- Types
   - `boolean`: 1 bit
   - `byte`: signed 8 bits (-128, 127)
   - `short`: signed 16 bits (-32768, 32767)
   - `char`: unsigned 16 bits ('\u0000', '\uFFFF')
   - `int`: signed 32 bits (![](https://g.yuque.com/gr/latex?-2%5E%7B31%7D#card=math&code=-2%5E%7B31%7D), ![](https://g.yuque.com/gr/latex?2%5E%7B31%7D%20-%201#card=math&code=2%5E%7B31%7D%20-%201)). Default number primitives for integer
   - `long`: signed 64 bits (![](https://g.yuque.com/gr/latex?-2%5E%7B63%7D#card=math&code=-2%5E%7B63%7D), ![](https://g.yuque.com/gr/latex?2%5E%7B63%7D%20-%201#card=math&code=2%5E%7B63%7D%20-%201))
   - `float`: single-precision 32-bit IEEE 754 floating point (1.40129846432481707e-45 to 3.40282346638528860e+38)
   - `double`: double-precision 64-bit IEEE 754 floating point(4.94065645841246544e-324d to 1.79769313486231570e+308d). Default number primitives for real number.
- Using `strictfp` keyword to make float point computation more precise
- When using an `int` variable, `int` cannot be converted to `boolean`:



```java
int flag = 1;
if (flag) System.out.println("aa");

// error: incompatible types: int cannot be converted to boolean
```


## Variables


- Declaration
   - Define a variable with a name
   - Multiple on a single line
- Initialization
   - Can be inline with declaration
   - Can be after declaration
   - Cannot reference a variable until initialized
- Naming
   - camelCase
   - Only `static final` use UPPER_SNAKE_CASE
   - Be descriptive with naming (don’t use aBox as a name)



## Operators


Arithmetic Shift and Logical (right) Shift
    - Arithmetic: consider signed bit(after a shift, add one bit which is same as prior signed bit)
    - Logical: always add 0



## Conversions and Casts


Several conversion types:



```java
12 + 14.1 // 12 is converted to double
10f - 17 // 17 is converted to float
50L + 10 // 10 is converted to Long

short foo = (short) 10;
10 + foo; // foo is converted to int
```


Careful as down-casting results in loss of precision:



```java
double foo = 99999.999d;
short bar = (short) foo;

// 'bar' is overflowed
```


## Arrays


- Use helper methods whenever necessary



```java
int a[] = new int[10];

Arrays.fill(a, 2);

Random random = new Random();
a[random.nextInt(10)] = random.nextInt();

Arrays.sort(a);
```


# Object Oriented Programming


## Basic Class


- Classes are templates for objects.
- Nouns = Class names, and Verbs = Method names



## Encapsulation


- Hides unnecessary complexity from the outside
- Java has many tools to properly encapsulate classes
   - Restricted variables / methods / classes
   - Patterns (getter/setter) to control access



## Immutable Objects


- Making Class variables as `final` makes them immutable.
- Prefer this when at all possible. Makes reasoning about object state easier and makes reasoning about concurrency much easier.



## Class Structure


```java
// 1 class signature
public class Employee {
    
    // 2 static variables
    private static final double DEFAULT_SALARY = 50000d;

    // 3 static methods
    public static Employee construct(String name, double salary) {
        return 
    }

    // 4 instance variables
    private final String name;
    private final double salary;

    // 5 instance constructors
    public Employee(string name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    // 6 instance methods
    public String getName() {
        return name;
    }
}
```


- Minimize static methods, because they are hard to test / not overridable
- Prefer immutable instance variables
- Prefer fully encapsulated instances (private instance variables with getter methods)
- Difference between `static` and `final`:
   - `static` emphasizes "only one", while `final` emphasizes "a constant"
   - A `static` variable, method, code block, ... is only initialized and executed for one time; `static` variable can be assigned a new value; `static` method has no `this` and `super` keywords
   - A `final` variable is immutable after declaration; A `final` method cannot be inheritted or override



## Constructor


- If not specified there’s a default (automatically created) no-args constructor. Yet if you define one constructor the default no-args constructor is not created. You can define yourself though
- Can have many constructors (as long as their signature is unique)
- Constructors can call other constructors



## Naming Convention in Class


- Use the same name for variable assignment in constructors- the this and shadowing approach (TaSA)
   - Succinct and descriptive naming is important but hard to do right.
   - The aParameterName construct mentioned in the textbook does not always work or becomes confusing. However, every parameter can be handled by the TaSA.



## Interlude - Packages


- Group similar classes by a namespace
- Commonly reverse domain notation (i.e., “com.google.xxxxx”)
- No package means the default package - NEVER do this.
- Classes should be organized in packages. Think of them like folder structures. In fact, classes should be placed in nested directories matching their package
structure. The period in the package denotes a new directory.



## Access Privileges


- `public`: the class is accessible to everyone everywhere
- `protected`: accessible to the Class itself, everyone within the same package and any subclass
- (default or package-private): the class is only accessible from other classes within the same package.
- `private`: accessible only to the Class itself (not subclasses)



## Interlude - Testing


- Do not use main method to test
   - Clutters the actual code
   - Not scalable to test all methods
- Use a testing framework like JUnit
   - Treat the test code as separate unit



```java
public class ZebraTest {
    @Test public void getName() {
        String name = "foobar";
        Zebra zebra = new Zebra(name);
        assertEquals(name, zebra.getName());
    }
}
```


## Method Invocation


- Call By Value
   - parameters to method are copied to new value
   - method cannot change reference (but can change values associated with the reference!)
- Call By Reference
   - parameters are sent by reference
   - allows method to change callee’s reference
- Java is CBV.



```java
public class MethodInvocationExample {
    public static void main(String[] args) {
        MethodInvocationExample cbv = new MethodInvocationExample();
        int left = 1, right = 2;
        cbv.invoke(left, right);
        // Call By value, left == 1, right == 2

        MethodInvocationExample cbr = new MethodInvocationExample();
        cbv.invoke(left, right);
        // Call By reference, left == 2, right == 2
    }
    public void invoke(int left, int right) {
        left = right;
        // if right == 2, left == 2
    }
}
```


```java
public class MethodInvocationExample {
    public static void main(String[] args) {
        MethodInvocationExample cbv = new MethodInvocationExample();
        Date date = new Date();
        date.setTime(0L);
        cbv.invoke(date);

        // Call by value, reference changed
        // date.getTime() will output 1
    }

    public void invoke(Date date) {
        date.setTime(1L); // modify current date object's value
        date = new Date(2L); // allocate a new object in memory, but does not modify the prior one
    }
}
```


## Method Overloading


- Methods can have the same name provided their signature(return type, name, numbers of parameters, parameter types) is different
- This rule also applies for constructor overloading



## Initialization


- Two basic ways to initialize: explicit field initialization and default initialization
- We can also use initialization blocks to initialize class and instance field values (but not local)
   - Initialization blocks are blocks of code (code surrounded by braces) which are run once.
   - Initialization blocks can be `static`
- Only one way to initialize a local variable, via explicit initialization



## Import


- Shortcut way of referencing other classes from outside your package
- Never necessary to import classes within java.lang



## Classpath


- Needed for compiling and invocation -> directly related to the imports
   - Reference via `-cp` or `-classpath` flag
- No need to add packages to the classpath starting with java.xxxx



# Inheritance In Java


- Classes can extend from others forming a hierarchy.



```java
public abstract class GameOfThronesHouse {...}
public abstract class GameOfThronesNorthernHouse extends GameOfThronesHouse {...}
public class StarkHouse extends GameOfThronesNorthernHouse {...}
```


- Classes extend from one and only one class
   - All classes, even if not explicitly specified, extend from at least one class. If not specified the class is Object
- Problems with multiple inheritance
   - If class C extends from both class A and class B and class A and class B implement a method called foo and C doesn’t override it, when invoked at runtime which method should be called, A’s or B’s?



## Polymorphism


- Many distinct types referenced by their shared supertype



```java
public class Animal {
    public String makeNoise() {
        return "";
    }
}
public class Cat extends Animal {
    @Override public String makeNoise() {
        return "meow";
    }
}
public class Dog extends Animal {
    @Override public String makeNoise() {
        return "woof";
    }
}
```


- Caution:
   - Dog is an Animal but not all Animals are Dogs
   - Java has covariant arrays (given type X and type Y which extends from X, then the array type, Y[] is an instance of X[].) which lead to issues with polymorphic types.



```java
// A possible error
class Animal {
    public String makeNoise() {
        return "";
    }
}
class Cat extends Animal {
    @Override public String makeNoise() {
        return "meow";
    }
}
class Dog extends Animal {
    @Override public String makeNoise() {
        return "woof";
    }
}

public class AnimalListener {
    public static void main(String[] args) {
        Dog[] dogs = new Dog[] { new Dog(), new Dog() };
        Animal[] animals = new Animal[] {};
        animals = dogs;
        animals[0] = new Cat();
        Dog dog = dogs[0];

        // Exception in thread "main" java.lang.ArrayStoreException: Cat
        // We cannot store a "cat" into a "dog" array
    }
}
```


## Keyword on Classes/Method


- Marking classes as `final` makes them immutable; i.e., they cannot be subclassed
- Marking methods as `final` makes them immutable; i.e., they cannot be overridden
- Marking classes and methods `final` is not a common practice. Some do this for “performance” but it makes unit testing hard and prevents any future extensibility.



```java
public final class FinalClass {
    // Cannot be extended
}

public class FinalMethod {
    public final String cannotBeOverridden() {
        return "always return this string!";
    }
}
```


## Cast/Instanceof


- Cast converts from one type to another
- `instanceof` checks if an object is an instance of a Class



```java
public class TypeCheck {
    public boolean isString(Object value) {
        return (value instanceof String);
    }
    public String coerce(Object value) throws ClassCastException {
        return (String) value;
    }
}
```


## Abstract Class


- Marking a class as `abstract` allows you to define functionality that can be leveraged by subclasses without allowing code to directly instantiate the type.
- Think of these as logical groupings but which cannot themselves exist (eg. You don’t just have an Animal, but always have something that is more specific like a Dog.)



## Abstract Method


- Abstract classes can also define methods to be implemented.
- You know a functionality should exist at the abstract level you just don’t know what it is concretely; delegate this decision to the concrete class.



## The Object Class


- Every class (not primitives) have the Object class as the root of their inheritance hierarchy.
- A class either extends from another(only explicitly) or from Object
- Several Object Class Methods
   - `getClass()`: returns the Class class instance
   - `hashCode()`: a hash code value for this object. Used in conjunction with equals for hash-table implementations.
   - `equals(Object obj)`: returns true if this object equals obj. Used to identify instantiated objects with like properties
   - `clone()`: returns a clone of this object
   - `toString()`: return a String representation of this object. Mostly used for logging
   - `notify()`: wakes up a thread listening for this object’s monitor
   - `notifyAll()`: like `notify` but wakes all threads listening for this object’s monitor
   - `wait(long) & wait(long, int) & wait()`: waits the current thread until another calls one of the notify methods. Overloaded methods with varying timeout.
   - `finalize()`: Called when no more references exist



## equals() Method Implementation Rules


- Reflexive: for any non-null x, `x.equals(x) == true`
- Symmetric: for any non-null x and y, `x.equals(y) == true` if and only if `y.equals(x) == true`
- Transitive: for any non-null x, y and z, if `x.equals(y) == true` and `y.equals(z) == true` then `x.equals(z) == true`
- Consistent: for any non-null x and y, `x.equals(y)` should, for repeated invocations, consistently return either true or false provided nothing under comparison has changed
- Null is false: for any non-null x, `x.equals(null) == false`



## hashCode() Method


- Consistent: if invoked on the same object more than once in same JVM then it
must return the same integer provided nothing under comparison has changed
- Equality: If x and y are equals (`x.equals(y) == true`) then their hash-code values must be the same (`x.hashCode() == y.hashCode() == true`)
   - This does not imply that unequal objects must have different hash-codes. They might often have collisions
   - Although hashCode values may change for the same object, this is un-advisable and can lead to hard to diagnose bugs.



## Auto Boxing & Unboxing

| Primitive type | Wrapper class |
| --- | --- |
| boolean | Boolean |
| byte | Byte |
| char | Char |
| float | Float |
| int | Integer |
| long | Long |
| short | Short |
| double | Double |



- Allows primitive values to be converted to and from their corresponding Object representations automatically by the compiler/JVM.
- JVM cache



```java
public class AnimalListener {
    public static void main(String[] args) {
        int first;
        Integer second, third;

        first = 127;
        second = 127;
        third = 127;

        System.out.printf("%s%n", (first == second)); // true
        System.out.printf("%s%n", (third == second)); // true

        first = 128;
        second = 128;
        third = 128;

        System.out.printf("%s%n", (first == second)); // true
        System.out.printf("%s%n", (third == second)); // false

        // JVM only caches Integer between [-128, 127]. If out of the range, two Integer object cannot simply compare with other using '=='
    }
}
```


## Variable Arguments


- Allows methods to be defined without knowing the exact number of arguments passed
- Super convenient when invoking methods though; use this whenever possible. Yet, arguments must be of the same type and must occur as the last argument of the method.



```java
public class Varargs {
    public static void main(String[] args) {
        Varargs varargs = new Varargs();
        varargs.print("a", "b", "c", "d");
    }

    public void print(String ... arguments) {
        for (String argument : arguments) {
            System.out.println(argument);
        }
    }
}
```


## Enum Types


- Enumeration of all possible values of a type at compile time
- Enum types are a special type of Class which can be extended and have instance fields and methods just like any other Object of a Class



```java
public enum GasolineGrade {
    Premium(97),
    Plus(93),
    Regular(87),
    Diesel(20);

    private final Integer octane;
    private GasolineGrade(Integer octane) {
        this.octane = octane;
    }
    private Integer getOctane() {
        return octane;
    }
}
```


# Interfaces


- Higher level templates than classes
   - Class = blueprint (template of how a building will look like when created); Object = creation of the blueprint (the actual building); Interface = commonalities between blueprints (house, skyscraper, library, etc)
- Interfaces are groupings of methods
   - Do not care about the implementation (Class) but want to express desired functionality
- All methods are public
- Interfaces cannot have instance variables (But defaultly have static final variables)
- Super interface: Interfaces can extend one another



```java
public interface Reader {
    void read(String text);
}

public interface BookReader extends Reader {
    void read(Book book);
}
```


- Interfaces without methods are called marker or tagging interfaces (in general don’t do this)



```java
public interface Serializable {}

public class Book implements Serializable {...}
```


- Classes can implement multiple interfaces



## Multiple Interfaces Inheritance


- A class can implement 0 to many interfaces. This is a very powerful way to get most of the benefits of multiple inheritance without the “double diamond” problem.



## Interface vs. Abstract Class


- More often than not prefer Interfaces
- Interfaces are cross-cutting concerns irrespective of concrete
type (Splitter, Searcher, Cloner, etc) and abstract-classes are something nearly concrete but which is shared by other concrete classes (e.g., AbstractEmployee is abstract class of Manager and Programmer)
- Typing to an interface allows for more flexibility in the future and makes tasks like testing much easier.
   - A good pattern is to first make an Interface then make an AbstractClass which implements that Interface and provide the common implementations then provide the ConcreteClasses.



```java
// old Employee structure
public abstract class Employee {
    
    private final String name;
    private final Double salary;
    
    Employee(String name, double salary) {
        this.name = name;
        this.salary = salary; 
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}


// new Employee structure
public interface Employee {
    String getName();
    Double getSalary();
}

abstract class AbstractEmployee implements Employee {
    private final String name;
    private final Double salary;
    
    AbstractEmployee(String name, Double salary) {
        this.name = name;
        this.salary = salary; 
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Double getSalary() {
        return salary;
    }
}


// we can easily extend new types of employee
public class SalesPerson extends AbstractEmployee implements Employee {
    private final String name;
    private final Double base;
    private final Double commission;
    
    AbstractEmployee(String name, Double base, Double commission) {
        this.name = name;   
        this.base = base;
        this.commission = commission;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Double getSalary() {
        return base + commission;
    }
}
```


## Callback Pattern


- Common for UI programming, asynchronous programming and as a way to pass function “pointers” around.



```java
public interface Callback {
    void loaded(String[] results);
}

public class CallbackImplementation implements Callback {
    @Override
    public void loaded(String[] results) {
        for (String result : results) {
            System.out.printf("%s%n", result);
        }
    }
}

public class CallbackInvoker {
    public void callAsynchronousTask(AsynchronousMethod async) {
        CallbackImplementation callback = new CallbackImplementation();
        async.invoke(callback);

        // return immediately, once the async task has completed the callback.loaded value will be called
    }
}
```


## Clones


- Do not use Object.clone()
   - Better ways to do this - immutable objects with constructors
   - Hard to maintain - if you add a field you have to ensure you update your clone method as well.



## Inner Classes


- Can mark the inner class private to hide from outside classes
- The inner class has an implicit reference to the outer class. Careful as this can leak
memory!



```java
public class Outer {
    public class Inner {
        private final Outer implicitReference;

        public Inner(Outer implicitReference) {
            this.implicitReference = implicitReference;
        }
    }
    public Inner createInner() {
        return new Inner(this);
    }
}
```


## Static Inner Classes


- The inner class can also be static
- Static inner class don't have an implicit reference to the outer class



```java
public class Processor {
    public static class Result {
        private final String result;

        public Result(String result) {
            this.result = result;
        }
    }
    public String getResult() {
        return result;
    }
}
```


## Local Classes


- Classes contained within a method
- Extremely rare to use (bad practice), yet there are completely hidden from outside world



## Anonymous Classes


- Classes inlined without a name
- Often see this with the Callback pattern
- Anonymous classes can access variables outside of themselves, but they don't have an implicit reference to the outer class



```java
public class AnonymousCallbackExample {
    public void callAsynchronousTask(AsynchronousMethod async) {
        async.invoke(new Callback() {
            @Override
            public void loaded(String[] results) {
                // ...
            }
        });
    }
}
```


# Exceptions/Debugging/Annotations/RegEx


## Exceptions


```java
public class ExceptionsExample {
    public static void main(String[] args) {
        if ((args == null) || (args.length != 1) || (args[0] == null)) {
            throw new IllegalArgumentException("Expect 1 argument which is a path to tile");
        }
        try {
            ExceptionsExample example = new ExceptionsExample(args[0]);
        } catch(IOException ioe) {
            System.out.println("Invalid file-name given");
        }
    }

    private final File file;

    public ExceptionsExample(String fileName) throws IOException {
        if (fileName == null) {
            throw new IllegalArgumentException();
        }
        this.file = new File(fileName);
    }
}
```


- A prescription for handling errors. “Exceptions” in Java are actually a subtype of `Throwable`. There are two main types that extend `Throwable`:
   - Exception, includes checked and unchecked exceptions
   - Error, an exception indicating a system failure
- How not to handle exceptions when coding:
   - Returning a “special” value (`null`, -1, ...)
- Instead use exceptions (most languages have a notion of exceptions) but only if the case is indeed exceptional (not simply for flow-control)
- Checked Exceptions: must be caught or rethrown, which is statically “checked” by the compiler
   - In general, only use if the program can recover from this failure. Does this exception have a graceful route to recovery
- Unchecked Exceptions: need not be caught, rethrown or declared
   - Only use when the program cannot be expected to recover from the failure
- Can even custom exceptions, though not often necessary



## Throwing Exceptions


- Done by using keyword `throw`
- Must declare checked exceptions as being ‘thrown’; do not have to but can declare unchecked exceptions
- Cannot override a method and throw a more generic exception



## Catching Exceptions


- Use the try/catch mechanism provided by Java
- If you do not catch the type thrown it is handled by the caller
   - If the exception is checked you must either catch it or declare your method as throwing it
   - If the exception is unchecked and not handled up the call-stack, then the JVM stops because of the “uncaught” exception
- If no exception is thrown within the try block, or if the type of the catch block does not match the thrown exception, then the catch block is not executed
- Multiple catch blocks are handled in order of declaration



## Rethrowing / Chaining Pattern


- To simplify your method signature (i.e., API) only throw one checked exception. Catch others and rethrow as one type.
   - Not necessary, use discretion



## Finally Clause


- Used in conjunction with the try block, to allow code to be executed no matter whether an exception is thrown or not



```java
public class FinallyClause {
    public void finallyClause(String path) {
        InputStream stream = null;
        try {
            stream = new FileInputStream(path);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe)
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch(IOException ioe) {
                    // try to close anyway...
                }
            }
        }
    }
}
```


## Exceptions and Logging


- Never print the exception stack-trace using `e.printStackTrace()`;
- Instead prefer a Logging implementation
   - Java provides a common API - java.util.logger
   - Latest/best is slf4j



```java
public class ExceptionLogging {
    private final static Logger LOG = Logger.getLogger(ExceptionLogging.class.getSimpleName());

    public InputStream open(String file) {
        try {
            return new FileInputStream(file);
        } catch (IOException ioe) {
            LOG.log(Level.SEVERE, ioe.getMessage(), ioe);
            return null;
        }
    }
}
```


## Debugging


- Do early and often
- Do not litter log statements into your program, instead use the debugger (jdb or an IDE).
- Always compile your code with `-Xlint:all`
- Do not debug code by adding a main method for testing. Test your code using unit-tests instead.



## Annotations


- Adds metadata to your code which can be used by programmers for clarity as well as compilers/tooling to do static code analysis (eg. `@Override`)
- May create your own annotation



```java
@Target(ElementType.METHOD)

@Retention(RetentionPolicy.RUNTIME)

public @interface Authorized {
    String headerKey() default "Bearer";
}
```


## Regular Expressions


- Two main classes
   - `java.util.regex.Pattern`
   - `java.util.regex.Matcher`



```java
import java.util.regex.*;

public class RegexExample {
    private static final Pattern REG_EX = Pattern.compile("\\d\\d");

    public static void main(String[] args) {
        RegexExample example = new RegexExample();
        example.match("Foo 01 Bar");
    }

    private void match(String input) {
        Matcher matcher = REG_EX.matcher(input);
        while (matcher.find()) {
            String match = matcher.group();
            System.out.printf("%s%n", match); 
        }
    }
    // output "01"
}
```


# Generics in Java


```java
public class Gift<T> {
    private final T value;
    private final Double cost;

    public Gift(T value, Double cost) {
        this.value = value;
        this.cost = cost;
    }

    public T getValue() {
        return value;
    }

    public Double getCost() {
        return cost;
    }
}
```


- Advantages
   - Enable code reuse in classes/interfaces.
   - Generics enable more compile type security.
   - Help eliminate explicit casting from code
- A class or interface can have zero to many generic types.
- Types must be defined after the class/interface name surrounded within < > characters. By convention a single uppercase letter is used
- Types can be defined to extend from or be super classes of other
types. E.g. `<T extends className>` or `<T super className>`
- Types are erased at compilation (not available at runtime)



## More in depth


- A class/interface with a generic type does not share the type hierarchy of its generic types.



```java
public class Echo<T> {
    public T echo(T value) {
        return value;
    }

    public Echo<T> echo(Echo<T> value) {
        return value;
    }
}


public class EchoChamber {
    public static void main(String[] args) {
        Echo<Number> numberEcho = new Echo<Number>();
        numberEcho.echo(10);
        numberEcho.echo(10d);
        numberEcho.echo(10f);
        numberEcho.echo(10L);

        // this part cannot compile
        // Integer -> Number != Echo<Integer> -> Echo<Number>
        numberEcho.echo(new Echo<Integer>());
        numberEcho.echo(new Echo<Double>());
        numberEcho.echo(new Echo<Float>());
        numberEcho.echo(new Echo<Long>());
    }
}
```


- Generic types can be bounded



```java
public class BoundedEcho<T> {
    public T echo(T value) {
        return value;
    }

    public BoundedEcho<T> echo(BoundedEcho<T> value) {
        return value;
    }
}


public class EchoChamber {
    public static void main(String[] args) {
        BoundedEcho<Number> numberEcho = new BoundedEcho<Number>();
        numberEcho.echo(10);
        numberEcho.echo(10d);
        numberEcho.echo(10f);
        numberEcho.echo(10L);

        BoundedEcho<String> stringEcho = new BoundedEcho<String>();
        // this part cannot compile
        // Integer -> Number != Echo<Integer> -> Echo<Number>
        numberEcho.echo(new BoundedEcho<Integer>());
        numberEcho.echo(new BoundedEcho<Double>());
        numberEcho.echo(new BoundedEcho<Float>());
        numberEcho.echo(new BoundedEcho<Long>());
    }
}
```


- A generic type can be bounded by multiple types. Only one of which can be a Class however.



```java
public class MultipleBounds<T extends Number & Comparable & Serializable> {
    private final T number;

    public MultipleBounds(T number) {
        this.number = number;
    }
    public T getNumber() {
        return number;
    }
}
```


- Generic types can be bounded by other generic types.



```java
public class BoundedGenericType<T, S extends T> {
    private final T value;
    private final S subValue;

    public BoundedGenericType(T value, S subValue) {
        this.value = value;
        this.subValue = subValue;
    }

    public T getValue() {
        return value;
    }

    public S getSubValue() {
        return subValue;
    }
}
```


- The generic parameter defined on the Class/Interface isn’t available in a static context.



```java
// this does not compile
public class GenericsAreNotStatic<T> {
    private static T reference;
}
```


- Generic types are not reified; i.e., after compilation they are removed and not available at runtime.
   - Cannot use primitive types as generic types (No `Gift<int>`)
   - Cannot use `instanceof` check for generically parameterized types (No `gift instanceof Gift<Computer>`)
   - Cannot make exception classes with generic types (No `public class MyException<T> extends Exception`)
   - Cannot have array types of generically parameterized types (No `Gift<Computer>[]`)



## Generics Defined at Methods


- Generic parameters can also be defined at a method level, but not at a field level
   - Static methods still do not have access to class generics



```java
public <S extends T> T transform(S value) {
    return value;
}

// this part does not compile
public static <S extends T> S echo(T value) {
    return value;
}
```


## Generics and Inheritance


- When extending/implementing classes/interfaces with generic parameters you must respect the super-types restrictions



## WildCard Type


- We want a generically typed Gift which is the supertype of all other generically typed Gift types
- Can only be used on instances, not class or methods;
- Only object can use wildcard type parameters (variable, method parameters, ...)



```java
public class GiftPrinter {
    public static void main(String[] args) {
        Gift<Computer> computerGift = new Gift<Computer>(new Computer(), 1500d);
        GiftPrinter printer = new GiftPrinter();
        printer.print(computerGift);
    }

    public void print(Gift<?> gift) {
        System.out.printf("%s%n", gift);
    }
}
```


- We have bounded wildcards



```java
public class BoundedWildcard {
    // If you need something to read of type T, then use this
    public void subClass(Gift<? extends T> gift) {
        //
    }

    // If you need something to consume of type T, then use this
    public void superClass(Gift<? super T> gift) {
        //
    }
}
```


# Collections In Java


- Data structure implementations found within the `java.util package`
- Nicely organized into a class hierarchy of: interface -> abstract class ->
(multiple) concrete classes



## Collection Interface


- the super interface/type of almost all the concrete types within the Java collections classes.
- Generally defined as `public interface Collection<E>`. The most commonly used are:
   - `boolean contains(Object obj)`
   - `boolean add(E element)`
   - `boolean remove(Object obj)`: only safe way to remove from a Collection while iterating is to use the Iterator remove method. Careful, must call `next` method before calling `remove`.
   - `void clear()`
   - `Iterator<T> iterator()`: a way to traverse elements of a Collection. Note that Anything that implements interface Iterable can be used in a for-each; which includes Collection types.



## List Interface


- Extends Collection
- Used when order matters (think of List as a replacement for arrays).
- Use `ArrayList` when random access is important. It is also dynamically
resized. Internally it is implemented with an array that is doubling each time resizing is necessary
- Use `LinkedList` when fast insertions is important. Internally it is
implemented as a doubly linked list
- There’s also something called `Vector`. Do not use this class. It is
synchronized but slower than List



Note the argument to the constructor - expected size of the List. Always do this. Otherwise you’ll have lots of resizing operations.


```java
List<String> list = new ArrayList<String>(2);
```


## Set Interface


- Extends Collection
- Used when fast retrieval at an unknown location is necessary.
- Use `HashSet` as it has constant time performance for most common
operations add/remove/contains/size. It, however, gives no guarantee as to the iteration order of elements.
- Use `TreeSet` when iteration order is important and needs to be sorted.
Order is given at a performance cost for operations add/remove/contains - log(n)



Note the argument to the constructor - expected size of the Set. Do this when possible. Otherwise you’ll have lots of resizing operations. The second argument is the “load factor”; i.e., at what point should the set be resized.


```java
Set<String> set = new HashSet<>(2, 1.0f);
```


## Map Interface


- Does not extends Collection
- Maps a key to a value
- Three common types:
   - `HashMap` - most common. Uses a hash table implementation.
   - `TreeMap` - analogous to TreeSet, used for ordering. Uses a red-black tree data structure.
   - `LinkedHashMap` - hybrid - linked-list and hash-table implementation. Uses a doubly linked list to maintain ordering of keys



Note the argument to the constructor - expected size of the Map. Do this when possible. Otherwise you’ll have lots of resizing operations. The second argument is the “load factor”; i.e., at what point should the map be resized.


```java
Map<String, Integer> map = new HashMap<>(2, 1.0f);
```


## Other Data Structures


- `Queue` - push/pop operations. Many implementations for FIFO or LIFO. Deque for double ended queue
- `PriorityQueue` - uses a heap data structure to maintain first element based on the priority ordering. Uses a Comparator to maintain order
- `NavigableSet` - sorted Set with methods to return elements of closest match; i.e., floor or ceiling to some element or return a collection of elements ‘higher’ than another.



## Views / Wrappers


- Convert an array to a List



```java
List<String> list = Arrays.asList("foo", "bar", "something else");
```


- Get a sublist from a list



```java
List<String> partial = list.sublist(1, 10);
```


## Algorithms


Collections class defines many commonly used algorithms.


- `Collections.sort` - variant of merge-sort. Sorts based on Comparator.
- `Collections.reverse` - useful when necessary
- `Collections.binarySearch` - extremely useful. Prefer when searching for an item within a collection that doesn’t offer O(1) lookup
- `System.arrayCopy` - use this to copy array types. Much more performant than manually copying (iterating and copying) as it uses native code



# Concurrency


Generally, multiple events happening at the same time. The trouble (in real life and in software development) is the interaction between these events.


## Two Problems


- Dining Philosophers Problem
   - Five silent philosophers sit around a table. In front of each is a bowl of rice. To each side of the philosopher is a single chopstick. Each philosopher must alternatively eat and think. A philosopher can pick up a chopstick on either side (right or left) but can only begin eating when holding two chopsticks. After eating the philosopher places both chopsticks back down. Assume the bowl of rice is bottomless (infinite rice within it).
   - Problem is to devise a scheme such that no philosopher starves.
- Producer / Consumer Problem
   - There’s a producer and a consumer sharing a fixed sized buffer. The job of the producer is to create data to put into the buffer. The job of the consumer is to remove data from the buffer.
   - A real life example of this might be an elevator. The elevator itself is the buffer as it’s fixed size (there is a maximum amount of people, or weight, allowed before it breaks). The producer is the logic responsible for allowing people onto the elevator. The consumer is the logic responsible for allowing people off.



## Race Condition


- When output is dependent upon the uncontrollable sequence of events.
   - Becomes a bug if the sequence of events happens in a way the programmer did not intend.
   - Means that a program can behave “correctly” even though it suffers from a race condition.
- The producer-consumer elevator problem suffers from a race condition. The output is dependent upon the order of the persons entering and leaving the elevator. In some cases it works (no bug), in some cases it fails (bug) but in all cases it suffers from a race condition.



## Deadlock


- Two (or more) resources are waiting for each other to finish and thus neither ever do finish.
   - We saw this in the Dining Philosophers. If we make a scheme where all philosophers pick up left chopstick and then wait to pick up right chopstick before putting down the left.



## Resource Starvation


- When a process/thread is perpetually denied resources.
   - An example of this is livelock. This is different than deadlock in that the program isn’t halted it however cannot move forward because it is continuously denied a resource.
   - In the Dining Philosophers problem change the deadlock scheme such that after all picking up the left chopstick the philosophers wait ten minutes, but down the left chopstick and then all pick up the right chopstick, wait ten minutes, etc.



## Atomicity


- An operation (or set of operations) appears to occur to components of a system instantaneously.
- The race condition in the producer-consumer-elevator problem and in the example were an indirect result of the assumption that a set of operations were atomic.
- Operations on long and double are not atomic (unless you use the `volatile` keyword)



## Mutual Exclusion


- For concurrent programs, mutual exclusion ensures that no two concurrent processes/threads are in a critical section at the same time.
   - A critical section is any portion of code which accesses a shared resource which cannot be accessed concurrently.
   - E.g., in the elevator example, there needs to be a mutual exclusion guarantee around the consumer decrementing the count of persons within the elevator and the act of removing a person from the elevator.



## Locks & Semaphores


- Locks - a synchronization mechanism to limit access to a shared resource; a way of implementing mutual exclusion.
- Semaphores - a particular type of Lock. Records how many units of a resource are available in conjunction with providing a safe (prevents race conditions) means of adjusting the record and potentially waiting for resources to become available.
   - A semaphore with an arbitrary resource count is called a counting semaphore.
   - A semaphore with value either 0 or 1 is called a binary semaphore.
   - Mutex - similar to a binary semaphore but often associates the notion of an owner such that only the owner can unlock the mutex (increment the semaphore back to 1).



## Monitor


- A synchronization mechanism that allows threads to have mutual exclusion and the ability to wait (block) for a condition to become true (e.g., there’s room within the elevator).
   - Monitors have a mechanism to signal waiting threads that a condition may have been met.
   - Monitors are implemented with a mutex lock and condition variables.
- Java loosely based its means of synchronization of objects based on this concept. However, fields are not all private (exposing state), methods are not forced to be synchronized (mutual exclusion) and the intrinsic lock (mutex) is exposed (it’s the object itself).
- General idea is to have one Lock object for all threads (per logical grouping of code needing mutual exclusion).



```java
Lock lock = new ReentrantLock();
Condition listNotEmpty = lock.newCondition;

lock.lock();
try {
    while (list.isEmpty()) {
        listNotEmpty.await();
    }
} finally {
    lock.unlock();
}
```


## Threads in Java


- By default there is one main Thread. You can create additional Thread objects and start them.
- Key elements are the Runnable object and the start and join methods.
- Never call `run` or `stop`
- Careful about interruptions -> always handle them, rethrow or terminate. If not handling them, call `Thread.currentThread().interrupt()`



## Visibility


- Writes to a shared variable on one thread can be seen by other threads.
   - With multiple threads, writing to a shared variable does not guarantee that other threads will immediately see the update or ever see the update.



```java
public class Invisible {
    private static boolean ready;
    private static int number;
    
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable(){
            @Override
            public void run() {
                while (!ready)
                    Thread.yield(); // current thread is willing to yield its current use of processor
                
                    System.out.printf("%d%n", number);
            }
        });

        thread.start();
        number = 100000;
        ready = true;
    }
}

// output 100000
```


## Keyword volatile


- Provides a weaker form of synchronization than using locking mechanisms.
- Marking a variable with `volatile` alerts the JVM that the variable will be shared amongst threads. Its value will not be cached (e.g. in registers); thus a read of a volatile variable will always be the most recent value written by a thread.\
- This does not make your variable/program thread-safe. Good use of volatile is simply to ensure the value of a variable is seen by all threads.



## Publication & Escape


- Publish: An object can be used by other threads outside of current scope
- Escape: A wrong publication. An object is observed by another thread before it is constructed



Several Methods to publish safely:


- Initialize a reference to the object in static init function
- Set the reference to a `volatile` scope
- Set the reference to a scope protected by lock



## Immutability


- Object is immutable if
   - All its fields are final
   - Its state cannot be modified after construction
   - It is properly constructed (does not escape during construction)
- Immutable objects are always thread-safe and thus preferred



## Thread Confinement


- Confining a resource/value to a thread means not sharing it across threads. Not sharing guarantees thread safety.
   - `Stack confinement` - seen in `RaceConditionWithLock`. Local variables are always thread safe as they’re confined to the stack and consequently to the thread running the stack.
   - `ThreadLocal` - a more formal means of allowing the programmer to maintain thread confinement by associating a per-thread object with a value holder object.



## Synchronization Mechanisms


- Lock in Java - ReentrantLock
- Lock with Condition
   - Must own lock to await on condition and must own lock to signal a condition
- Lock without Condition



## Java’s Built-in Synchronization


- Java loosely based its means of synchronization of objects based on this concept. However, fields are not all private (exposing state), methods are not forced to be synchronized (mutual exclusion) and the intrinsic lock (mutex) is exposed (it’s the object itself).
- Every Object has an intrinsic lock (and one condition).
   - Not the same as Lock/Condition. Every synchronized can be rewritten as Lock/Condition but not every Lock/Condition can be rewritten using synchronized
- Synchronized as a block or around any method
   - If around method, using the intrinsic lock of the Object
   - If used within a block the programmer must specify which Object to use as the lock. Can use `this` for the current Object; Can use `Class.class` for the Object’s class (to lock all Objects of a given class).



## Thread-safe Collections/Utilities


- Look at classes within package `java.util.concurrent`
- `AtomicInteger`, `AtomicBoolean`, `AtomicLong`, `AtomicReference`, which provides atomic interactions (get and set, etc)
- `ConcurrentMap` (interface) and `ConcurrentHashMap` (implementation)
- `BlockingQueue` - allows you to easily implement Producer/Consumer



## Executors


- Java 1.5 provided a framework for interacting with Threads which abstracts logic of starting/stopping and executing work.
   - `Executor` - interface of something which can process work
   - `ScheduledExecutor` - extends `Executor` but allows the programmer to control over when and how frequent work is done
   - `ExecutorService` - similar to a “thread pool”; owns a number of `Executor`objects. Get an instance of this and give it work.
   - `ScheduledExecutorService` - same as an `ExecutorService` but also can schedule jobs (ScheduledExecutor).
   - `Executors` - utility class which creates `ExecutorService` and `ScheduledExecutorService` objects.



# I/O in Java


- Input and output of bytes from files/sockets/etc
- Newest: NIO2 (new new IO) classes/object (also in package java.nio): Better File/Path abstractions



## Input/Output Streams


- InputStream (`java.io.InputStream`): Blocking read bytes from some source (file, network, etc)
- OutputStream (`java.io.OutputStream`): Blocking write bytes to some destination (file, network, etc)
- InputStream/OutputStream are fairly low-level. Reading/writing a single byte or array of bytes at a time.
   - Do not take into account file encodings/character sets
   - Cannot be (easily) interrupted
- Most common and the ones we’ll be using are：
   - FileInputStream / FileOutputStream
   - BufferedInputStream / BufferedOutputStream
   - PrintStream
   - Reader / Writer Buffered & File variants
   - Closeable / Autocloseable / Flushable / Appendable interfaces



## FileInputStream


- Extends InputStream to assist in reading byte values from a File



## BufferedInputStream


- Extends InputStream to provide buffered reading, or writing in analogous BufferedOutputStream



## Reader


- InputStream / OutputStream (and their subclasses) do not take character encodings into account. Use Reader to solve this problem
- Character encodings: ways of representing characters as bytes
- Java handles character encoding using the Charset abstraction
   - Each platform / machine has a default Charset (or character encoding). Many machines use UTF-8 as the default
- Has subclasses like InputStreamReader, FileReader, BufferedReader / etc



## Closeable / Autocloseable


- Must close all of the classes we’ve mentioned
   - Remember to always wrap with a `try/finally`, or (if Java 1.7) and the class implements Autocloseable use the try-with-resources



```java
public void openAndClose(String file) {
    FileInputStream stream = null;
    try {
        stream = new FileInputStream(file);
        // do something
    } catch (IOException ioe) {
        // handle exception
    } finally {
        if (stream != null) {
            try {
                stream.close();
            } catch(IOException ioe) {
                // print or do nothing
            }
        }
    }
}
```


## NIO


- IO calls block the invoking thread until the IO operation completes (or fails). Additionally, they don’t (always) leverage platform specific efficient operations (like memory mapped files, direct file copy, etc).
- NIO (in Java) provided mechanisms to perform non-blocking IO operations, memory mapped files and more access to platform specific operations (like file copying).
- NIO is built on different paradigms (than IO which is stream based)
   - Buffers
   - Channels
   - Selectors



## NIO-Buffers

![NIOBuffer.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Java/NIOBuffer.png)

Typically, this would be used to allow the buffer contents to occupy the same physical memory used by the underlying operating system for its native I/O operations, thus allowing the most direct transfer mechanism, and eliminating the need for any additional copying.



## NIO-Channels


- Provide bulk data transfer to/from NIO Buffer objects.
- Obtained from the higher-level objects (FileInputStream, sockets, etc)



## NIO-Selectors


- Provides a way of waiting on Channel objects and recognizing when one or more become available for data transfer.
- Register a Selector with a Channel
- The Selector can provide a more efficient implementation using lower-level operating system constructs.



## Handling Network Sockets (Blocking & Non-Blocking)

![Blocking.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Java/Blocking.png)

![Nonblocking.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Java/Nonblocking.png)


## New NIO - Java 7 File Abstractions


- Provides convenience methods for interacting with file systems and files
   - `FileSystem` - interaction with the underlying file system
   - `Path` - a location to directories and files within a `FileSystem`
   - `Files` - convenience class (like Collections) to assist in doing common tasks related to File objects (copy, move, etc)
- Provided platform-agnostic notions of determining if files were hidden, symbolic, etc.



# Functional Java & Other Java 8 Features


## Default / Static Interface Methods


- Java 8 allows developers to define methods on interfaces which have default implementations (like methods within an abstract class).
   - Updating an existing interface with a default method allows all implementations of the interface to be source compatible.



```java
public interface List<T> extends java.util.List<T> {
    static <T> void swap(List<T> list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }

    default void reverse() {
        for (int i = 0, mid = size() >> 1, j = size() - 1; i < mid; i++, j--) {
            swap(this, i, j);
        }
    }

    default void shuffle() {
        throw new UnsupportedOperationException();
    }
}
```


- Java 8 also allows developers to define static methods within an interface.
   - This allows developers to tie relevant code directly to where it’s applicable
(i.e., instead of having a Collections class, these methods could be directly written as static methods within the Collection interface).



```java
public interface List<T> extends java.util.List<T> {
    static <T> void swap(List<T> list, int i, int j) {
        list.set(i, list.set(j, list.get(i)));
    }

    static <T> void reverse() {
        for (int i = 0, mid = size() >> 1, j = size() - 1; i < mid; i++, j--) {
            swap(this, i, j);
        }
    }
}
```


## Default Interface Methods - Inheritance


- When you extend an interface with default methods, you have the following options:
   - Ignore; the subinterface inherits the default method (including its implementation)
   - Redefine; redefining the method with a new default implementation overrides the default method from the super interface
   - Redeclare; re-declaring the method on the subinterface makes the method abstract (the default method from the super interface is now abstract for subinterface implementations)
- This logic is the same as normal inheritance in Java (including ‘redeclare’ for abstract classes).



## Default Interface Methods - Multiple Inheritance Resolution


- In Java, one can extend from only one class but can extend from multiple interfaces.
   - Now, with default methods, a class can inherit more than one method with the same signature
- If a class inherits the same method signature from multiple super types, it must resolve the conflict according to the following rules:
   - Classes win. A method defined in a class or superclass takes priority over any default method declaration.
   - Else, subinterfaces win. The most specific subinterface default method implementation wins (If interface B extends A, B is more specific than A and so B’s default methods take precedence).
   - Finally, if still ambiguous, the inheriting class must explicitly choose. This is done via overriding the method.



## Functional Programming


- Programming using functions where functions produce no side effects, which never mutates data and is referentially transparent(Invoking it with the same input should always produce the same output)
- Java has functional-style of programming
   - A function can only mutate local variables (those defined within the function)
   - Not all methods in Java are referentially transparent (e.g. `Random.nextInt`)



## Functional Programming Concepts


Supported in Java:


- First Class Functions: use functions like other values
- Higher Order Functions: take functions as parameters and return functions
- Currying: where a function of two (or more) arguments is seen as a function taking one argument and returning another function (or functions) of one argument [e.g. f(x,y) = (g(x)) (y) ]



Not Supported in Java:


- Tail Recursion: because loops introduce mutation, recursion is leveraged. To avoid stack memory proportional to input, use tail recursion which is where the recursive call happens as the final act of the procedure
- Pattern Matching: matching based on structure
- Algebraic Data Types: type formed by combining other types



## Lambda Expressions


- Java’s name for adding functions as first class values.
- A lambda expression in Java is a concise representation of an anonymous function (specifically a functional interface) which can be passed around
   - Anonymous - the function does not have a name
   - Function - it is not associated with a particular class or method (but is an implementation of a functional interface)
   - Concise - new syntax is introduced in Java 8 to minimize boilerplate code



## Functional Interface


- An interface specifying exactly one abstract method
- All functional interfaces can be implemented via
   - A class (as we’ve seen)
   - An anonymous class (as we’ve seen)
   - A lambda expression (new to Java 8)
- Java 8 introduces an annotation `@FunctionalInterface` to provide metadata for those interfaces being defined as functional interfaces



## Lambda Expression Syntax


- Lambda expressions follow two patterns of syntax
   - (parameters) -> expression
   - (parameters) -> { statements; }
- Parameters
   - A comma delimited list of named parameters surrounded by parenthesis. The type is
optional but if included comes prior to the named parameter (e.g. String value)
   - If only one parameter is used, the parenthesis are optional
- Arrow
   - Separates the parameters from the body
- Body
   - Either a single expression or one to many statements. Note, an expression is evaluated for the return type. If you explicitly specify ‘return’ you must enclose in braces (as it’s then considered a statement)
- Note, the return type is not explicitly specified but inferred.



```java
public static void main(String[] args) {
    Function<?, ?> function = (String value) -> System.out.printf("%s%n", value);

    function = (value) -> System.out.printf("%s%n", value);

    function = value -> System.out.printf("%s%n", value);

    Runnable voidFunction = () -> Thread.currentThread().interrupt();

    BiFunction<?, ?, ?> biFunction = (String value, String another) -> {
        System.out.printf("%s%n", value);
        System.out.printf("%s%n", another)
        return String.format("%s %s", value, another);
    }
}
```


## Method References


- Java 8 provides a more compact syntax for referring to methods, called method references.
- Syntax leverages a double colon and is either
   - a. Type::MethodName
   - b. Object::MethodName
- There are four incarnations of this syntax
   - Static Method [uses syntax (a)] - e.g. to reference the static method atan on Math class - `Math::atan`
   - Instance Method of arbitrary type [uses syntax (a)] - e.g. to reference the instance method isEmpty on String class - `String::isEmpty`
   - Instance Method of existing object [uses syntax (b)] - e.g. to reference the instance method `toUpperCase` on an object named ‘professorName’ of type String - `professorName::toUpperCase`
   - Constructors [uses syntax (a)] - technically the same as #2 but you use the ‘new’ keyword; e.g. `String::new`
- Overloading issues: there are multiple overloaded toString methods on Integer. Compiler is not ‘smart’ enough to figure out which to use. Can resolve (this particular one, not all) by explicitly referencing the Object type.



```java
DoubleBinaryOperator biFunction = Math::pow;

List<String> values = new ArrayList<>();
values.sort(String::compareTo);

Function<?, ?> function = System.out::equals;

Runnable voidFunction = Thread.currenthread()::interrupt;

Function<String, Bmw> bmwConstructor = Bmw::new;

// Wrong
Function<Integer, String> stringifier = Integer::toString;
// Correct
Function<Integer, String> stringifier = Object::toString;
```


## Provided Functional Interfaces


```java
Function<T, R>   T -> R
BiFunction<T, U, R>   (T, U) -> R
Predicate<T>   T -> boolean
BiPredicate<L, R>   (L, R) -> boolean
Consumer<T>   T -> void
BiConsumer<T, U>   (T, U) -> void
Supplier<T>   () -> T
UnaryOperator<T>   T -> T
BinaryOperator<T>   (T, T) -> T
```


## Stream


- The Stream API is a way to declaratively modify data.
   - The data can be contained within a Java Collection but it is not limited to this and can be other data like that within an array or from I/O.
- How is this different than interacting with a Collection?
   - A collection is a data structure in memory holding all its elements at once. Think of this as a CD holding songs
   - A stream is a conceptual data structure where elements are only computed on demand. Think of this as a streaming music service like Spotify
- Pipelining
   - Many stream functions return another Stream. This allows operations to be chained together. This pipelining can be exploited to perform operations lazily and even short circuit operations.
- Internal Iteration
   - Iteration is done within the Stream
- Streams have two types of operations
   - Intermediate - produce another Stream. This is how pipelining works
   - Terminal - produce an end result (not a Stream). This not only starts but also completes the Stream
- Note, streams can only be consumed once



## Null Safety


- Introduce `Optional` type to help resolve unsafety issues raised by the `null` value
- The `java.util.Optional` type provides a type safe solution
   - Includes convenience methods; like get, isPresent, orElse, et al
   - Mimics Stream like functionality; map, flatMap, filter



```java
public class PartyPlanning {
    private final Party party;

    public PartyPlanning(Party party) {
        this.party = party;
    }

    public Optional<Party> getOptParty() {
        return Optional.ofNullable(party);
    }

    public Optional<Double> getPlannerCost() {
        return getOptParty().flatMap(Party::getOptPlanner).flatMap(Planner::getOptCost).flatMap(Cost::getOptAmount);
    }
}
```


# Libraries/Testing/Patterns


## Libraries


- Included in your project via jar files
- Use a build tool or the jar executable (included in JDK) to create a jar
file of your project
- Many (many) libraries available for Java
   - Search online -> maven central repository is best source for quality libraries



## Some Useful Libraries


- Guava - Provides a large amount of supplemental “core” Java type functionality
   - Immutable Collections
   - Caching
   - String Utilities
- Jackson - Easy JSON



## Testing


- Testing
   - Testing code by units (i.e. methods) makes reasoning about the correctness of your code much easier.
   - Testing ensures you’ve correctly created working code and ensures the integrity of your assumptions across time.
- JUnit
   - Put test classes in `src/test`
   - Name the test class `ClassNameToBeTestedTest`. The suffix should be `Test`
   - Write a unit test for every public method. Also a good practice to test private/protected/default methods as well - necessitates using reflection
   - Name the unit test method the same as the method being tested
   - To mark a method as a testing method annotate it with `@Test`
   - To invoke code prior to every test, make a method and annotate it with `@Before`
   - To invoke code after every test, make a method and annotate it with `@After`
   - Can ignore tests by annotating the method with `@Ignore`
- Mockito
   - Often when unit testing you’ll want to “mock” the implementation of a class so that you can test all scenarios.
   - For a better unit testing
   - Keep in mind that final classes and final methods cannot be mocked
