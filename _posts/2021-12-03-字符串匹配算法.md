---
title: 字符串匹配算法
tags: Algorithms Computer-Science
article_header:
  type: 
  image:
    src: 
---

三种经典的字符串匹配算法：KMP、Rabin-Karp、Boyer-Moore

<!--more-->

以下三种算法，都可以用于“在给定的字符串A中判断是否能找到字符串B，并给出B的所有所在位置”这一场景，并且复杂度要比传统的暴力方法低很多。三种算法的时间复杂度都是`O(m+n)`，其中`m`, `n`分别是字符串`text`, `pattern`的长度。

## KMP算法


KMP算法(Knuth-Morris-Pratt Algorithm)相比起传统的暴力搜索法，避免了搜索失败后的重复无意义的回退，因而显著降低了时间复杂度。


假设有以下两个字符串A和B：

- A: abbaabbaaba
- B: abbaaba



现在要从A中搜索到是否有子字符串等于B，以及这个子字符串的位置。按照传统方案，A、B都从头开始匹配搜索，当搜索到第7个字符时发现不相同，匹配失败，则A要回退到第2个字符，B回退到第1个字符开始继续匹配......这种方法无疑很浪费时间，此时我们希望有一种方法，使得匹配失败时，B尽可能少地回退，并且B回退的部分和A已经匹配过了，这样A就不用回退了。


如何确定B回退后的位置？观察发现，这次失败的匹配中，比较的前6个字符abbaab是相同的。如果用abbaab的前缀匹配后缀，最长匹配结果就是答案。这里需要引出两个概念：

- abbaab的前缀集合有{a, ab, abb, abba, abbaa}（注意，前缀集合中不包含本身）
- abbaab的后缀集合有{b, ab, aab, baab, bbaab}（注意，后缀集合中不包含本身）



匹配失败时，比较前后缀集合，得到长度最长的公共结果。在上文描述的情境中，ab是最长的公共匹配。这样我们就能确认，此时A所在位置之前的2个字母，与B的前2个字母是相同的，都是ab。于是我们可以跳过这两个字母，让B回退到第3个字符继续和A匹配。根据这个例子举一反三，我们完全可以假定B在其所有位置都跟A无法匹配上，因此B可以在配对前预先算好其所有位置的最长匹配长度，得到一个表，之后发生不匹配时查表就能快速确定回退位置。于是这也引出了一个新概念：

- 部分匹配表(Partial Match Table)：字符串的前缀集合与后缀集合的交集中最长元素的长度。我们规定任意与A匹配的字符串B(又称为模式串)，在匹配前都需要先算出部分匹配表



画图用另一个字符串abababca为例，其部分匹配表如下：


![KMP-1.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/KMP-1.png)

明确了基本的匹配原理后，我们可以研究如何快速计算部分匹配表。考虑字符串abababzabababa，假如我们正在计算其部分匹配表，最后一个字母a处的最大匹配数尚未求出：

```
子字符串　 a b a b a b z a b a b a b a
最大匹配数 0 0 1 2 3 4 0 1 2 3 4 5 6 ?
```
在求出?值之前，我们可以观察已经求出的最大匹配数(6，即ababab)；而次大匹配数为4(abab)，并且我们可以发现次大匹配必定在最大匹配中(abab就是ababab的最大匹配)。依次类推，第三大的匹配字符串就是次大匹配字符串abab中的最大匹配，即ab，长度为2。依照这个方法，我们从?前的6开始判断，因为ababab之后的z和a显然不匹配，我们就找到次大的4，即abab，正好abab之后的a与末尾的a匹配，因此?的值就是4 + 1 = 5，我们进而快速地完成了一位的最大匹配数计算。

最后附上代码：


```java
int[] calculateMaxMatchLengths(String pattern) {
    int[] maxMatchLengths = new int[pattern.length()];
    int maxLength = 0;
    for (int i = 1; i < pattern.length(); i++) {
        while (maxLength > 0 && pattern.charAt(maxLength) != pattern.charAt(i)) {
            maxLength = maxMatchLengths[maxLength - 1]; // ①
        }
        if (pattern.charAt(maxLength) == pattern.charAt(i)) {
            maxLength++; // ②
        }
        maxMatchLengths[i] = maxLength;
    }
    return maxMatchLengths;
}

// 由 ② 可以看出 maxLength 在整个 for 循环中最多增加 pattern.length() - 1 次，所以让 maxLength 减少的 ① 在整个 for 循环中最多会执行 pattern.length() - 1 次，从而 calculateMaxMatchLengths 的复杂度是线性的


// 在文本 text 中寻找模式串 pattern，返回所有匹配的位置开头
List<Integer> search(String text, String pattern) {
    if (pattern.length() == 0) {
        return 0;
    }
    if (text.length() == 0) {
        return -1;
    }
    
    List<Integer> positions = new ArrayList<>();
    int[] maxMatchLengths = calculateMaxMatchLengths(pattern);
    int count = 0;
    for (int i = 0; i < text.length(); i++) {
        while (count > 0 && pattern.charAt(count) != text.charAt(i)) {
            count = maxMatchLengths[count - 1];
        }
        if (pattern.charAt(count) == text.charAt(i)) {
            count++;
        }
        if (count == pattern.length()) {
            positions.add(i - pattern.length() + 1);
            count = maxMatchLengths[count - 1];
        }
    }
    return positions;
}
```


## Rabin-Karp算法
Rabin-Karp算法的核心思想是利用hash函数，把字符串变成整数，这样就能降低比较操作的时间复杂度。

假设有以下两个字符串txt和pat：

- txt: abcde
- pat: bcd



我们使用hash函数，把字符串变成整数。例如对于字符串abcde，我们可以做如下转化：

```
abcde = a * 31 + b * 31 + c * 31 + d * 31 + e * 31
```

- 这个数字可能很大，我们需要进行取模
- 为什么用31？理论上任何数字都可以，但是一般选用素数，不容易产生hash值冲突



结合上文提到的txt和pat，模拟一下查找流程：


1. 计算pat的hash值patHash
1. 根据pat长度，从txt获取前3位字母abc，计算得到hash值x
1. 比较发现x和patHash不相等，于是再从txt中获取1位字母，现在用4个字母abcd计算hash值，注意计算公式为 `x = (x * 31 + d) % MOD`
1. 比较发现新hash值x仍然与patHash不相等，并且发现此时用来计算hash的字符串长度已经超过了pat，于是我们移除首个字母a，这样就得到了3个字母bcd，再次和pat长度相等。用bcd计算hash值，公式为`x = (x * 31 + d) % MOD - a * 31 ^ pat.len % MOD`
1. 比较发现新hash值与patHash相等。然而，因为存在极小概率发生hash值冲突，我们还不能完全确定此时的遍历子字符串就是pat，必须真正把字符串提取出来，以字符形式逐步比较加以确认



注意计算过程中，如果在移除首字母后计算的hash值为负数，再添加一个MOD即可。并且我们也能发现，hash函数的选择是影响Rabin-Karp算法性能的关键，如果产生了大量hash值冲突，就需要多次进行真正的字符串遍历比较，算法的最坏性能可能退化至O(mn)。


最后附上代码：
```java
public int RabinKarp(String txt, String pat) {
    if (pat.length() == 0) {
        return 0;
    }
    if (txt.length() == 0) {
        return -1;
    }
    int m = pat.length();
    int MOD = 1000000;

    // 计算power，也就是幂，用于后面删除头用，所以要多计算一位
    int power = 1;
    for (int i = 0; i < m; i++) {
        power = power * 31 % MOD;
    }

    // 计算pat的hash值
    int patHash = 0;
    for (int i = 0; i < m; i++) {
        patHash = (patHash * 31 + pat.charAt(i)) % MOD;
    }

    // subHash
    int subStrHash = 0;
    int n = txt.length();
    for (int i = 0; i < n; i++) {
        subStrHash = (subStrHash * 31 + txt.charAt(i)) % MOD;
        // 如果不够pat的长度
        if (i < m - 1) {
            continue;
        }
        // 如果超过pat的长度,要去掉头
        if (i >= m) {
            subStrHash = subStrHash - (txt.charAt(i - m) * power) % MOD;
            if (subStrHash < 0) {
                subStrHash += MOD;
            }
        }

        // double check
        if (subStrHash == patHash) {
            if (txt.subSequence(i - m + 1, i + 1).equals(pat)) {
                return i - m + 1;
            }
        }
    }
    return -1;
}
```


## Boyer-Moore算法
Boyer-Moore算法的核心思想是预先生成Bad Character和Good Suffix，并且总是从尾部往头部比对，快速跳过大量字符，进而降低了时间复杂度。


假设有以下两个字符串text和pattern：

- text: HERE IS A SIMPLE EXAMPLE
- pattern: EXAMPLE



首先，text和pattern头部对齐，从尾部开始比较。这样做很聪明，因为尾部如果不相同，就可以知道在此之前的几个字母整体上都不是符合条件的结果。可以发现，text中的S和pattern中的E不相同，此时S就被称为坏字符(Bad Character)；并且我们还发现，S不在pattern中，因此我们可以直接把pattern后移到S之后的一位继续搜索。

![Booye-Moore-1.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-1.png)

接下来依然从尾部开始比较，发现text中的P和pattern中的E不同，此时P就被称为坏字符(Bad Character)；然而P在pattern中，所以我们只能把pattern后移2位，使得text中的P和pattern中的P对齐。

![Booye-Moore-2.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-2.png)

![Booye-Moore-3.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-3.png)

根据以上例子，我们可以总结出遇到坏字符时，pattern的后移规则：


```java
后移位数 = 坏字符在text匹配字段中的位置 - 坏字符在pattern中上一次出现的位置 （位置均从0开始计数）
```


- 以前文P为例，其在text匹配字段中的位置是6，而pattern中的位置是4，因此需要后移2位
- 以更之前的S为例，其在text匹配字段中的位置是6，而pattern中的位置是-1（表示未出现在pattern中），因此需要后移7位



继续进行匹配。可以发现，text匹配字段中的后4个字母和pattern的后4个字母相同，都是MPLE。这种情况称为好后缀(Good Suffix)，即所有尾部匹配的字符串。此处除了MPLE，PLE、LE、E也都是好后缀。

![Booye-Moore-4.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-4.png)

再往前匹配1位，发现text中的I和pattern中的A不相同。此时根据坏字符原则，pattern应该后移2 - (-1) = 3位。但鉴于我们同时存在着好后缀，我们也可以利用好后缀原则进行后移：


```java
后移位数 = 好后缀在text匹配字段中的位置 - 好后缀在pattern中上一次出现的位置 （位置均从0开始计数）
```

- 好后缀的位置，以最后一个字符为准。因此对于上文中的一系列好后缀，它们的位置都取决于最后一个E，也就是6
- 如果好后缀在pattern中只出现了一次，则它的上一次出现的位置就是-1。例如ABCDEF之中，假如EF是好后缀，但它只出现了一次，那么它上一次出现的位置就是-1
- 如果好后缀有多个，除了最长的那个，其他好后缀的上一次出现位置必须在头部。在上文中的诸多好后缀里，只有E在pattern的头部出现，因此此时只能采用E作为好后缀，上次出现的位置是0，后移6 - 0 = 6位



经过上述比较，我们发现坏字符规则可以后移3位，而好后缀原则可以后移6位。显然，我们二者求其大。这也是Bayes-Moore算法的核心：每一次匹配失败后移时，都计算出两个原则的后移位数，采纳较大值。

![Booye-Moore-5.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-5.png)

之后继续进行比较，发现text中的P和pattern中的E不同，根据坏字符规则pattern后移2位；再之后从尾部逐位比较，发现完全匹配，于是搜索结束。如果还需要继续查找出pattern在text中的全部匹配情况，则根据好后缀原则，后移6 - 0位继续进行搜索。

![Booye-Moore-6.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-6.png)

![Booye-Moore-7.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Algorithms/Booye-Moore-7.png)


最后附上代码：


```java
private void getSuffix(String pattern, int m, int[] suffix) {
    int i, j;
    suffix[m - 1] = m;
    char[] p = pattern.toCharArray();
    for (i = m - 2; i >= 0; i--) {
        j = i;
        while (j >= 0 && p[j] == p[m - 1 - i + j]) {
            j--;
        }
        suffix[i] = i - j;
    }
}

private void preBmBc(String pattern, int[] bmBc) {
    int m = pattern.length();
    int i;
    char[] p = pattern.toCharArray();
    for (i = 0; i < 256; i++) {
        bmBc[i] = m;
    }
    for (i = 0; i < pattern.length() - 1; i++) {
        bmBc[p[i]] = m - 1 - i;
    }
}

private void preBmGs(String pattern, int[] bmGs) {
    int i = 0;
    int m = pattern.length();
    int[] suff = new int[m];
    getSuffix(pattern, m, suff);

    // case3
    for (i = 0; i < m; i++) {
        bmGs[i] = m;
    }

    // case2
    int j = 0;
    for (i = m - 1; i >= 0; i--) {
        if (suff[i] == i + 1) {
            for (; j < m - 1 - i; j++) {
                if (bmGs[j] == m) {
                    bmGs[j] = m - 1 - i;
                }
            }
        }
    }

    // case1
    for (i = 0; i < m - 1; i++) {
        bmGs[m - 1 - suff[i]] = m - 1 - i;
    }
}

public int strStr(String text, String pattern) {
    if (text == null || text.isEmpty()) {
        return (pattern == null || pattern.isEmpty()) ? 0 : -1;
    } else if (pattern == null || pattern.isEmpty()) {
        return 0;
    }

    int p_len = pattern.length();
    int t_len = text.length();
    int[] bmGs = new int[p_len];
    int[] bmBc = new int[256];
    char[] p = pattern.toCharArray();
    char[] t = text.toCharArray();
    preBmBc(pattern, bmBc);
    preBmGs(pattern, bmGs);
    int j = 0;
    int i = 0;
    while (j <= t_len - p_len) {
        for (i = p_len - 1; i >= 0 && p[i] == t[i + j]; i--) {
            ;
        }
        if (i < 0) {
            return j;
        } else {
            j += Math.max(bmGs[i], bmBc[t[i + j]] - (p_len - 1 - i));
        }  
    }
    return -1;
}
```
