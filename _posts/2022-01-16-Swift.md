---
title: Swift
tags: Notes Computer-Science Swift
article_header:
  type: 
  image:
    src: 
---

Swift Learning Notes

<!--more-->

# 简介

Swift语言由苹果公司推出，是一种现代化、强大、直观的编程语言，适用于iOS, macOS，tvOS，watchOS等系统。这个语言通过现代化的设计，避免了一些日常编程中遇到的经常遇到的问题：

- 变量未初始化就被使用
- 数组访问越界
- 整数溢出
- 空值处理
- 自动内存管理
- 错误处理及恢复

# 快速上手
## Hello World

Swift的Hello world:
```swift
print("Hello World!")
```
这里有2个需要注意的地方：

- 这一行代码已经是一个完整的程序，不需要引入任何库进行输入输出(与传统的C/Objective-C不同)；也不需要手动添加main()函数作为函数入口(类似Python)，因为全局所用域下的代码默认就是函数入口
- 不需要在行末添加分号

## 常量与变量
与其他语言相似，Swift中有常量与变量的概念，在声明时分别需要用let和var进行修饰。常量在声明后就不可以被再次赋值修改。Swift推荐在能使用常量的场合下，尽可能使用常量。
```swift
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```
如果要声明多个常量/变量，可以用逗号分隔：
```swift
var x = 0.0, y = 0.0, z = 0.0
```

---

在声明变量时，可以显式地添加类型注释，指定变量的类型；也可以直接赋值，由编译器进行隐式的类型推断。一般来说，编译器的类型推断可以正确应付大部分给定的初始值，这为开发者节省了不少时间。
```swift
var welcomeMessage: String
var red, green, blue: Double
```

---

Swift变量名中不能含有空格、数学符号、箭头、'-'，也不能以数字作为起始字符。与一些传统语言不同的是：

- Swift支持使用Unicode字符作为变量名或变量值，因此诸如emoji表情之类的符号可以被使用
- Swift支持起一个与保留关键字相同的变量名，如果要这么做的话，需要在变量名两侧添加'`'。但一般而言这种做法不被提倡
```swift
let 🐶🐮 = "dogcow"
let emoji = "🐶"

let `let` = 3
```

---

要打印变量值，调用print()函数即可。如果变量值需要嵌入在一个String中一并输出，可以使用\()的方式输出：
```swift
let friendlyWelcome = "Bonjour!"
print(friendlyWelcome)
print("The current value of friendlyWelcome is \(friendlyWelcome)")
```
## 注释
与C语言类似，Swift拥有单行注释和多行注释的功能，分别用//和/* */进行标注：
```swift
// This is a comment.

/* This is also a comment
but is written over multiple lines. */
```
在此基础上，Swift支持嵌套多行注释，这对于在大型项目已有注释的代码上进一步补充注释十分方便：
```swift
/* This is the start of the first multiline comment.
 /* This is the second, nested multiline comment. */
This is the end of the first multiline comment. */
```
## 分号
Swift并不强制要求在行尾添加分号。然而，如果要在同一行中写入多句表达式，就需要使用分号进行间隔：
```swift
let cat = "🐱"; print(cat)
```
# 变量类型
## 整数
Swift提供了8、16、32、64位的有符号/无符号整数。对于不同位数的整数，都可以获取到其支持的最大/最小值。例如获取无符号8位整数的最小与最大值：
```swift
let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
```
多数情况下，开发者并不需要选择自己需要多少位的整数，只需要使用Int或者UInt类型即可。在32位的机器上，Int的长度等同于Int32的长度；在64位的机器上，Int的长度等同于Int64的长度。UInt也是类似。

 如果要让某个变量强行存储一个超出变量类型范围的值，将会引起错误：
```swift
let cannotBeNegative: UInt8 = -1
// UInt8 can't store negative numbers, and so this will report an error

let tooBig: Int8 = Int8.max + 1
// Int8 can't store a number larger than its maximum value,
// and so this will also report an error
```
## 浮点数
Swift中的有两种类型的浮点数：

- Float，表示32位浮点数
- Double，表示64位浮点数


这两种浮点数都是有符号类型的。在二者都可以使用的场景下，推荐使用Double类型，保证更高的精确度。
## 整数和浮点数的转化
如果要进行这两种变量的互相转化，必须显式地指定转换类型：
```swift
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi equals 3.14159, and is inferred to be of type Double
```
特别地，由浮点数转为整数会引起舍入误差，只会保留浮点数的整数部分：
```swift
let integerPi = Int(pi)
// integerPi equals 3, and is inferred to be of type Int
```
## 类型推导
Swift的类型推导允许开发者直接给变量赋值，而不用显式声明变量类型。所赋的值可以来源于一个混合了多种变量类型的表达式：
```swift
let meaningOfLife = 42
// meaningOfLife is inferred to be of type Int

let pi = 3.14159
// pi is inferred to be of type Double

let anotherPi = 3 + 0.14159
// anotherPi is also inferred to be of type Double
```
## 数值字面量(Numeric Literals)
对于一些不同进制的整数，Swift允许开发者在数字前添加相应的前缀进行指定：



- 十进制：默认无前缀
- 二进制：0b
- 八进制：0o
- 十六进制：0x
```swift
let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
```
对于浮点数，Swift支持十进制和十六进制两种表达。

- 对于十进制，可以添加一个e表示指数，后面加上幂的大小
- 对于十六进制，有0x的前缀，可以添加一个p表示指数，后面加上幂的大小
```swift
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```
不论是整数浮点数，Swift都允许在不改变变量值的前提下，添加任意数量的'0'或者是下划线'_'，以此保证更好的可读性：
```swift
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```

## 变量类型别名(Typealias)


Swift允许为变量类型取一个别名，方便使用：


```swift
typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min
// maxAmplitudeFound is now 0
```
## 布尔值(Boolean)


Swift中的布尔值只有true和false两种值。与C语言不同，Swift中的布尔值不能被转化成0和1去理解，因此在布尔判断中，0和1不能作为判断条件：


```swift
let orangesAreOrange = true
let turnipsAreDelicious = false


let i = 1
if i {
    // this example will not compile, and will report an error
}


let i = 1
if i == 1 {
    // this example will compile successfully
}
```
## 元组(Tuple)


Swift允许将若干个值组合在一起，变成一个复合值，即tuple。tuple可以存放任意类型的值，不同值的变量类型也不需要相同。tuple可以方便某些场合下返回一系列变量值。


一般情况下，tuple的使用和拆解过程如下：
```swift
let http404Error = (404, "Not Found")
// http404Error is of type (Int, String), and equals (404, "Not Found")


let (statusCode, statusMessage) = http404Error
print("The status code is \(statusCode)")
// Prints "The status code is 404"
print("The status message is \(statusMessage)")
// Prints "The status message is Not Found"


let (justTheStatusCode, _) = http404Error
print("The status code is \(justTheStatusCode)")
// Prints "The status code is 404"
```
此外，tuple在初始化时可以直接指定类型和值；在使用时也可以不拆解，直接访问其中的变量名。某种程度上，这种用法贴近结构体和类的思想：
```swift
let http200Status = (statusCode: 200, description: "OK")

print("The status code is \(http200Status.statusCode)")
// Prints "The status code is 200"
print("The status message is \(http200Status.description)")
// Prints "The status message is OK"
```
## 可选值(Optional)


Swift引入了Optional变量的概念。当一个变量不确定是否为空值时，可以将变量声明为Optional，相当于在原来的变量类型外面嵌套了一层外衣，这个外衣只有两个值：有值和无值。Optional类型的符号是在其他变量类型后加一个问号'?'。


Optional类型的变量可以主动声明得到，由此这个变量可以被赋值为空值(nil)；如果声明Optional之后不赋值，默认值也会被编译器声明为nil：
```swift
var serverResponseCode: Int? = 404
// serverResponseCode contains an actual Int value of 404
serverResponseCode = nil
// serverResponseCode now contains no value

var surveyAnswer: String?
// surveyAnswer is automatically set to nil
```


如果将一个字符串转为整数类型时，得到的就是一个Optional类型变量，因为字符串转化有可能失败，不能保证一定会得到一个整数类型：
```swift
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
```

---



要确保Optional变量有值，必须显式地判断变量值是否和nil相等。在确保某个值不是空值的时候，使用!符号提取(unwrap)出Optional变量中的值：
```swift
if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// Prints "convertedNumber has an integer value of 123."
```
这一判断流程往往能结合控制逻辑，判断需不需要执行某段代码。常用的方法是使用可选值绑定（Optional Binding），即当发现某个变量中有值时，将这个值提取出来赋值给一个新变量，之后就可以直接使用这个新变量，省去频繁unwrap的麻烦。


第一种Optional Binding的方式是if let，即只有当前Optional变量有值时，才会执行if代码块中的语句：
```swift
if let constantName = someOptional {
    statements
}



if let actualNumber = Int(possibleNumber) {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
}
// Prints "The string "123" has an integer value of 123"
```
第二种Optional Binding的方式是guard let，如果当前Optional变量为空值，就会直接执行else中的语句：
```swift
guard let constantName = someOptional {
    statements
}

guard let name = name else {
    return
}
```

---

某些情况下，我们认为一些Optional变量只要设定了初始值，之后就会始终有值，不会再变成nil。由此，我们可以将变量声明为隐式解析可选值(Implicitly unwrapped optional)，这样在使用时这个变量时就不需要多次判断解析变量。


Implicitly unwrapped optional在变量声明时就需要指定，只需要将原来optional中的'?'符号替换为'!'符号。编译器会尝试先将其当成是一个普通的Optional变量进行使用；如果发现这个变量有值，则会强制解析出其中的变量值。
```swift
let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation point

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation point

let optionalString = assumedString
// The type of optionalString is "String?" and assumedString isn't force-unwrapped.
```
注意，如果一个Implicitly unwrapped optional变量实际上为空值时，试图解析其变量值的操作就会触发错误。为此，我们仍然需要进行空值检查。在确保有值的前提下，我们既可以像使用普通Optional变量那样，显式地再解析一次；也可以直接使用，因为这个变量声明时已经隐式解析过了。


```swift
if assumedString != nil {
    print(assumedString!)
}
// Prints "An implicitly unwrapped optional string."


if let definiteString = assumedString {
    print(definiteString)
}
```
# 运算符号(Operators)


Swift中根据运算数的个数，可以将运算符分为三类：



- 一元运算符：作用于单个操作数，往往直接写于操作数左侧或右侧。例如-a或者a!
- 二元运算符：作用于两个操作数。例如两个数的加减乘除(+ - * /)，赋值( = )，运算后赋值(+=, -=, *=, /=)，比较(==, <, >, <=, >=)，部分逻辑符号(&&, ||)
- 三元运算符：作用于三个操作数。与C类似，Swift只有一个三元运算符，用于条件判断，即a ? b : c



此外，Swift有一些独特的符号，需要留意：


- 空值合并运算符(Nil-Coalescing)：a ?? b，本质上是a != nil ? a! : b的缩写，用于快速为一个Optional空值变量提供一个替代的默认值
- 范围操作符，具体又细分为
   - 全闭，即a...b，表示从a到b的范围，包括a和b
   - 半闭，即a..<b，表示从a到b的范围，包括a但不包括b
   - 单侧，即a...或者...b，遍历范围将取决于具体的Collection类型，可能会从某个位置开始遍历到结束，或是从开头遍历到某个位置停止

---

对于逻辑操作符，Swift中&&和||都是left associated的，所以默认不需要添加括号也能明确优先级；不过开发者仍然可以显式地添加括号，增加可读性：

```swift
if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "Welcome!"


if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {
    print("Welcome!")
} else {
    print("ACCESS DENIED")
}
// Prints "Welcome!"
```
# 字符串与字符(Strings and Characters)
## 字符串字面量(String Literals)


Swift的字符串通过头尾引号"标注：

```swift
let someString = "Some string literal value"
```
如果字符串很长，需要写在多行中，可以使用"""标注在头尾：
```swift
let quotation = """
The White Rabbit put on his spectacles.  "Where shall I begin,
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on
till you come to the end; then stop."
"""



let lineBreaks = """

This string starts with a line break.
It also ends with a line break.

"""
```
为了增加可读性，也可以在多行字符串中人为添加换行符‘\'：
```swift
let softWrappedQuotation = """
The White Rabbit put on his spectacles.  "Where shall I begin, \
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on \
till you come to the end; then stop."
"""
```
注意，多行字符串中可以使用缩进，因此要注意缩进的空间，避免输出字符串时产生空格：
![indentation.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/indentation.png)

---

Swift的字符串支持一些特殊字符：


- \0：空字符
- \\：反斜线
- \t：制表符
- \n：换行符
- \', \"：单双引号转义
- \u{n}：十六进制下的Unicode字符表示。n是一个1~8位的十六进制数


一种特殊情况是，在多行字符串中如果要插入三个"""，我们可以只转义第一个引号，也可以三个都转义：
```swift
let threeDoubleQuotationMarks = """
Escaping the first quotation mark \"""
Escaping all three quotation marks \"\"\"
"""
```


如果想要确保多行字符串中的所有转义符号都不起效，只是被打印出来而已，可以在字符串两侧分别添加#号：

```swift
let threeMoreDoubleQuotationMarks = #"""
Here are three more double quotes: """
"""#
```
## 字符串初始化
要声明一个空字符串，可以认为赋值，也可以调用类构造函数，二者得到的是相同的结果：
```swift
var emptyString = ""               // empty string literal
var anotherEmptyString = String()  // initializer syntax
// these two strings are both empty, and are equivalent to each other
```
判断字符串是否为空：
```swift
if emptyString.isEmpty {
    print("Nothing to see here")
}
```
## 字符串的值
字符串可以被声明为常量或者变量。如果声明为变量，它的值就可以被反复修改：
```swift
var variableString = "Horse"
variableString += " and carriage"
// variableString is now "Horse and carriage"

let constantString = "Highlander"
constantString += " and another Highlander"
// this reports a compile-time error - a constant string cannot be modified
```
注意在Swift中，String是值类型，因此当某个String作为参数被传递到其他方法中，或者赋值给另一个String变量时，都会在内存中进行值拷贝生成一个新的String对象，后续操作只会影响这个新的对象，不影响原来的对象。
## 字符


字符串中的每个字符都是Character类型。可以通过遍历字符串得到详情：

```swift
for character in "Dog!🐶" {
    print(character)
}
// D
// o
// g
// !
// 🐶
```
声明单个字符：
```swift
let exclamationMark: Character = "!"
```
可以通过人为构造一个Character数组，将其转化为String：
```swift
let catCharacters: [Character] = ["C", "a", "t", "!", "🐱"]
let catString = String(catCharacters)
print(catString)
// Prints "Cat!🐱"
```
## 字符串拼接


直接使用运算符进行两个字符串的拼接：

```swift
let string1 = "hello"
let string2 = " there"et multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message is "3 times 2.5 is 7.5"

var welcome = string1 + string2
// welcome now equals "hello there"


var instruction = "look over"
instruction += string2
// instruction now equals "look over there"
```
如果要在字符串后添加字符，可以使用String类中的append方法：
```swift
let exclamationMark: Character = "!"
welcome.append(exclamationMark)
// welcome now equals "hello there!"
```
## 值嵌入


使用\()将变量值嵌入到String中。注意有时候需要进行类型转化：
```swift
let multiplier = 3
let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
// message is "3 times 2.5 is 7.5"



print(#"6 times 7 is \#(6 * 7)."#)
// Prints "6 times 7 is 42."
```
## 字符串统计
String中的count属性统计的是String中的Character个数：
```swift
let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
print("unusualMenagerie has \(unusualMenagerie.count) characters")
// Prints "unusualMenagerie has 40 characters"
```
由于Swift使用了Extended grapheme cluster机制，因此对String进行的字符添加并不一定会影响到String中的Character个数：
```swift
var word = "cafe"
print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in cafe is 4"

word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301

print("the number of characters in \(word) is \(word.count)")
// Prints "the number of characters in café is 4"
```
由于这一机制的存在，不同字符在内存中占有的空间并不一定相同，将Swift的String转为Objective-C的NSString时，也可能会产生长度上的变化
```swift
var str = "Hello 😘" // the square is an emoji
str.characters.count // returns 7
(str as NSString).length // returns 8
```
## 字符串下标访问


Swift字符串有两个下标属性：

- startIndex：字符串的第一个Character
- endIndex：字符串最后一个Character之后的一个位置


此外，还有一个offSetBy属性，用于计算从某个下标之后偏移若干位置后的下标：

```swift
let greeting = "Guten Tag!"
greeting[greeting.startIndex]
// G
greeting[greeting.index(before: greeting.endIndex)]
// !
greeting[greeting.index(after: greeting.startIndex)]
// u
let index = greeting.index(greeting.startIndex, offsetBy: 7)
greeting[index]
// a


greeting[greeting.endIndex] // Error
greeting.index(after: greeting.endIndex) // Error
```
可以通过indices属性遍历所有下标：
```swift
for index in greeting.indices {
    print("\(greeting[index]) ", terminator: "")
}
// Prints "G u t e n   T a g ! "
```

---

得到下标后，我们可以在字符串特定位置插入或删除一个字符或者一个字符串：

```swift
var welcome = "hello"
welcome.insert("!", at: welcome.endIndex)
// welcome now equals "hello!"

welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex))
// welcome now equals "hello there!"



welcome.remove(at: welcome.index(before: welcome.endIndex))
// welcome now equals "hello there"

let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex
welcome.removeSubrange(range)
// welcome now equals "hello"
```

---

通过上述下标的截取，我们还可以得到子字符串：

```swift
let greeting = "Hello, world!"
let index = greeting.firstIndex(of: ",") ?? greeting.endIndex
let beginning = greeting[..<index]
// beginning is "Hello"

// Convert the result to a String for long-term storage.
let newString = String(beginning)
```
## 字符串比较
使用==或者!=进行字符串比较：
```swift
let quotation = "We're a lot alike, you and I."
let sameQuotation = "We're a lot alike, you and I."
if quotation == sameQuotation {
    print("These two strings are considered equal")
}
// Prints "These two strings are considered equal"
```
注意，只要两个字符串即使两个字符串在语言语义上相同，即便Unicode层面有着微小的差异，也会被视作相同：
```swift
var word = "cafe"
var newWord = "cafe" + "\u{301}"
print(word == newWord)
// return true
```

---

使用hasPrefix()和hasSuffix()方法，可以快速选出具有特定前缀、后缀的字符串：

```swift
let romeoAndJuliet = [
    "Act 1 Scene 1: Verona, A public place",
    "Act 1 Scene 2: Capulet's mansion",
    "Act 1 Scene 3: A room in Capulet's mansion",
    "Act 1 Scene 4: A street outside Capulet's mansion",
    "Act 1 Scene 5: The Great Hall in Capulet's mansion",
    "Act 2 Scene 1: Outside Capulet's mansion",
    "Act 2 Scene 2: Capulet's orchard",
    "Act 2 Scene 3: Outside Friar Lawrence's cell",
    "Act 2 Scene 4: A street in Verona",
    "Act 2 Scene 5: Capulet's mansion",
    "Act 2 Scene 6: Friar Lawrence's cell"
]



var act1SceneCount = 0
for scene in romeoAndJuliet {
    if scene.hasPrefix("Act 1 ") {
        act1SceneCount += 1
    }
}
print("There are \(act1SceneCount) scenes in Act 1")
// Prints "There are 5 scenes in Act 1"



var mansionCount = 0
var cellCount = 0
for scene in romeoAndJuliet {
    if scene.hasSuffix("Capulet's mansion") {
        mansionCount += 1
    } else if scene.hasSuffix("Friar Lawrence's cell") {
        cellCount += 1
    }
}
print("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
// Prints "6 mansion scenes; 2 cell scenes"
```
## Unicode表示


前文曾提到String与NSString的字符串长度差异，这是因为Swift这边的String默认用的是21bit Unicode scalar字符编码方式，等相当于UTF-32，而OC中的NSString用的是UTF-16字符编码方式。事实上，Swift中共有UTF-8, UTF-16, UTF-32三种表达方式，区别就在于Code unit不同：
![char1.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/char1.png)

![char2.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/char2.png)

![char3.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/char3.png)

# 集合类型(Collection Types)
## 数组(Array)
将所有元素存储于一个有序列表中。

---

数组的创建如下，可以直接创建一个空数组或者添加预设值，也可以指定某个值重复多次，或者是多个数组的拼接
```swift
var someInts: [Int] = []
print("someInts is of type [Int] with \(someInts.count) items.")
// Prints "someInts is of type [Int] with 0 items."


var shoppingList: [String] = ["Eggs", "Milk"]
// shoppingList has been initialized with two initial items


var threeDoubles = Array(repeating: 0.0, count: 3)
// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]


var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]


var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
```

---

数组的增删改查：
```swift
if shoppingList.isEmpty {
    print("The shopping list is empty.")
} else {
    print("The shopping list isn't empty.")
}


shoppingList.append("Flour")
// shoppingList now contains 3 items, and someone is making pancakes


shoppingList += ["Baking Powder"]
// shoppingList now contains 4 items
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
// shoppingList now contains 7 items


var firstItem = shoppingList[0]
// firstItem is equal to "Eggs"
shoppingList[0] = "Six eggs"
// the first item in the list is now equal to "Six eggs" rather than "Eggs"


shoppingList.insert("Maple Syrup", at: 0)
// shoppingList now contains 7 items
// "Maple Syrup" is now the first item in the list


let mapleSyrup = shoppingList.remove(at: 0)
// the item that was at index 0 has just been removed
// shoppingList now contains 6 items, and no Maple Syrup
// the mapleSyrup constant is now equal to the removed "Maple Syrup" string


let apples = shoppingList.removeLast()
// the last item in the array has just been removed
// shoppingList now contains 5 items, and no apples
// the apples constant is now equal to the removed "Apples" string
```

---

数组的遍历：
```swift
for (index, value) in shoppingList.enumerated() {
    print("Item \(index + 1): \(value)")
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas
```
## 集合(Set)


集合中的所有元素必须是不同的，并且没有固定的顺序。被存储在Set中的元素必须是可以hashable的，即必须生成hash value用于判断两个元素之间是否相同。

---

集合的创建如下，可以直接生成空集合手动添加，也可以通过数组辅助添加。注意集合中会自动应用类型推导：

```swift
var letters = Set<Character>()
print("letters is of type Set<Character> with \(letters.count) items.")
// Prints "letters is of type Set<Character> with 0 items."
letters.insert("a")
// letters now contains 1 value of type Character
letters = []
// letters is now an empty set, but is still of type Set<Character>


var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
// favoriteGenres has been initialized with three initial items


var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
```

---

集合的增删改查：
```swift
print("I have \(favoriteGenres.count) favorite music genres.")
// Prints "I have 3 favorite music genres."


if favoriteGenres.isEmpty {
    print("As far as music goes, I'm not picky.")
} else {
    print("I have particular music preferences.")
}
// Prints "I have particular music preferences."


favoriteGenres.insert("Jazz")
// favoriteGenres now contains 4 items


if let removedGenre = favoriteGenres.remove("Rock") {
    print("\(removedGenre)? I'm over it.")
} else {
    print("I never much cared for that.")
}
// Prints "Rock? I'm over it."


if favoriteGenres.contains("Funk") {
    print("I get up on the good foot.")
} else {
    print("It's too funky in here.")
}
// Prints "It's too funky in here."
```

---

集合的遍历，注意默认情况下集合遍历是无序的，如果需要有序，可以借助sorted方法进行值排序：
```swift
for genre in favoriteGenres {
    print("\(genre)")
}
// Classical
// Jazz
// Hip hop


for genre in favoriteGenres.sorted() {
    print("\(genre)")
}
// Classical
// Hip hop
// Jazz
```

---

集合的四种逻辑运算类型：

![relation1.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/relation1.png)

```swift
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
```
此外，还可以判断两个集合之间是否存在父子集关系与相交关系：

![relation2.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/Swift/relation2.png)

```swift
let houseAnimals: Set = ["🐶", "🐱"]
let farmAnimals: Set = ["🐮", "🐔", "🐑", "🐶", "🐱"]
let cityAnimals: Set = ["🐦", "🐭"]

houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
```
## 字典(Dictionary)
存储键值对。注意键必须是Hashable的，这一点与Set类似。

---

字典的创建可以从空开始创建，或者是借助字面量。注意当所有key类型相同、所有value类型也相同时，可以利用Swift自动类型推导的特点，省去初始化时声明字典类型：
```swift
var namesOfIntegers: [Int: String] = [:]
// namesOfIntegers is an empty [Int: String] dictionary


namesOfIntegers[16] = "sixteen"
// namesOfIntegers now contains 1 key-value pair
namesOfIntegers = [:]
// namesOfIntegers is once again an empty dictionary of type [Int: String]


var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
// or
var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
```

---

字典的增删改查：
```swift
print("The airports dictionary contains \(airports.count) items.")
// Prints "The airports dictionary contains 2 items."


if airports.isEmpty {
    print("The airports dictionary is empty.")
} else {
    print("The airports dictionary isn't empty.")
}
// Prints "The airports dictionary isn't empty."


airports["LHR"] = "London"
// the airports dictionary now contains 3 items


airports["LHR"] = "London Heathrow"
// the value for "LHR" has been changed to "London Heathrow"
```
由于字典中可能不存在某个key，或者存在某个key但不存在对应的value，因此需要考虑到Optional的情况：
```swift
if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") {
    print("The old value for DUB was \(oldValue).")
}
// Prints "The old value for DUB was Dublin."


if let airportName = airports["DUB"] {
    print("The name of the airport is \(airportName).")
} else {
    print("That airport isn't in the airports dictionary.")
}
// Prints "The name of the airport is Dublin Airport."


airports["APL"] = "Apple International"
// "Apple International" isn't the real airport for APL, so delete it
airports["APL"] = nil
// APL has now been removed from the dictionary


if let removedValue = airports.removeValue(forKey: "DUB") {
    print("The removed airport's name is \(removedValue).")
} else {
    print("The airports dictionary doesn't contain a value for DUB.")
}
// Prints "The removed airport's name is Dublin Airport."
```

---

字典的遍历，既可以遍历键值对本身，也可以单独遍历键或值，或者提取到数组中：
```swift
for (airportCode, airportName) in airports {
    print("\(airportCode): \(airportName)")
}
// LHR: London Heathrow
// YYZ: Toronto Pearson


for airportCode in airports.keys {
    print("Airport code: \(airportCode)")
}
// Airport code: LHR
// Airport code: YYZ

for airportName in airports.values {
    print("Airport name: \(airportName)")
}
// Airport name: London Heathrow
// Airport name: Toronto Pearson


let airportCodes = [String](airports.keys)
// airportCodes is ["LHR", "YYZ"]

let airportNames = [String](airports.values)
// airportNames is ["London Heathrow", "Toronto Pearson"]
```
## 集合的可变/不可变性


取决于声明集合时定义为常量还是变量，只要是变量就是可变的，可以添加、删除、修改集合中的元素。
# 控制流(Control Flow)
## For循环


最基础的for in循环，可以直接快速遍历集合中的元素：
```swift
let names = ["Anna", "Alex", "Brian", "Jack"]
for name in names {
    print("Hello, \(name)!")
}
// Hello, Anna!
// Hello, Alex!
// Hello, Brian!
// Hello, Jack!
```
for in循环可以搭配范围使用，注意遍历时遇到的值如果不用，可以用_替代：
```swift
for index in 1...5 {
    print("\(index) times 5 is \(index * 5)")
}
// 1 times 5 is 5
// 2 times 5 is 10
// 3 times 5 is 15
// 4 times 5 is 20
// 5 times 5 is 25


let base = 3
let power = 10
var answer = 1
for _ in 1...power {
    answer *= base
}
print("\(base) to the power of \(power) is \(answer)")
// Prints "3 to the power of 10 is 59049"
```
有时我们希望间隔遍历，可以在for in循环上加上stride指定间隔：
```swift
let hours = 12
let hourInterval = 3
for tickMark in stride(from: 3, through: hours, by: hourInterval) {
    // render the tick mark every 3 hours (3, 6, 9, 12)
}
```
## While循环
第一种while循环与其他语言类似：
```swift
while condition {
    statements
}
```
第二种则和C语言中的do-while接近，不过变成了repeat-while：
```swift
repeat {
    statements
} while condition
```
## 条件语句
最简单的条件语句是if，当判断条件为true时执行后续语句：
```swift
var temperatureInFahrenheit = 30
if temperatureInFahrenheit <= 32 {
    print("It's very cold. Consider wearing a scarf.")
}
// Prints "It's very cold. Consider wearing a scarf."
```

---

Switch语句则可以方便地进行多个条件下的判断与跳转：
```swift
switch some value to consider {
case value 1:
    respond to value 1
case value 2,
     value 3:
    respond to value 2 or 3
default:
    otherwise, do something else
}
```
注意：

- 每一个case下不需要break
- 必须穷尽所有可能，不能遗漏值

​

Swift中不允许有case被隐式地转到另一种case下进行处理。如果有多个case共享同一种处理方式，需要在同一行中用逗号分隔开多个case：
```swift
let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a": // Invalid, the case has an empty body
case "A":
    print("The letter A")
default:
    print("Not the letter A")
}
// This will report a compile-time error.



let anotherCharacter: Character = "a"
switch anotherCharacter {
case "a", "A":
    print("The letter A")
default:
    print("Not the letter A")
}
// Prints "The letter A"
```
Switch还可以用来处理区间与tuple：
```swift
let approximateCount = 62
let countedThings = "moons orbiting Saturn"
let naturalCount: String
switch approximateCount {
case 0:
    naturalCount = "no"
case 1..<5:
    naturalCount = "a few"
case 5..<12:
    naturalCount = "several"
case 12..<100:
    naturalCount = "dozens of"
case 100..<1000:
    naturalCount = "hundreds of"
default:
    naturalCount = "many"
}
print("There are \(naturalCount) \(countedThings).")
// Prints "There are dozens of moons orbiting Saturn."



let somePoint = (1, 1)
switch somePoint {
case (0, 0):
    print("\(somePoint) is at the origin")
case (_, 0):
    print("\(somePoint) is on the x-axis")
case (0, _):
    print("\(somePoint) is on the y-axis")
case (-2...2, -2...2):
    print("\(somePoint) is inside the box")
default:
    print("\(somePoint) is outside of the box")
}
// Prints "(1, 1) is inside the box"
```
Switch可以进行值判定，或者通过where进行判断：
```swift
let anotherPoint = (2, 0)
switch anotherPoint {
case (let x, 0):
    print("on the x-axis with an x value of \(x)")
case (0, let y):
    print("on the y-axis with a y value of \(y)")
case let (x, y):
    print("somewhere else at (\(x), \(y))")
}
// Prints "on the x-axis with an x value of 2"



let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
// Prints "(1, -1) is on the line x == -y"
```
## 控制转移
常见的控制转移关键词有：

- continue：跳过当前循环中的剩余语句，继续执行下一次循环
- break：跳过当前循环
- fallthrough：效仿C语言的switch语句，执行完case后还会再执行default的情况
- return：返回值
```swift
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime number, and also"
    fallthrough
default:
    description += " an integer."
}
print(description)
// Prints "The number 5 is a prime number, and also an integer."
```

---

此外，Swift提供了标签语句，用于更精确地进行控制代码块的运行：
```swift
let finalSquare = 25
var board = [Int](repeating: 0, count: finalSquare + 1)
board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
var square = 0
var diceRoll = 0

gameLoop: while square != finalSquare {
    diceRoll += 1
    if diceRoll == 7 { diceRoll = 1 }
    switch square + diceRoll {
    case finalSquare:
        // diceRoll will move us to the final square, so the game is over
        break gameLoop
    case let newSquare where newSquare > finalSquare:
        // diceRoll will move us beyond the final square, so roll again
        continue gameLoop
    default:
        // this is a valid move, so find out its effect
        square += diceRoll
        square += board[square]
    }
}
print("Game over!")
```
## API可用性
Swift中允许用户指定为不同版本SDK提供不同的运行代码：
```swift
if #available(platform name version, ..., *) {
    statements to execute if the APIs are available
} else {
    fallback statements to execute if the APIs are unavailable
}


if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}
```
# 函数(Functions)
## 基本组成


函数由func关键字定义，并且有名字、参数、返回类型：
```swift
func greet(person: String) -> String {
    let greeting = "Hello, " + person + "!"
    return greeting
}
```
函数可以有0～多个参数和返回值：
```swift
func sayHelloWorld() -> String {
    return "hello, world"
}
print(sayHelloWorld())
// Prints "hello, world"



func greet(person: String, alreadyGreeted: Bool) -> String {
    if alreadyGreeted {
        return greetAgain(person: person)
    } else {
        return greet(person: person)
    }
}
print(greet(person: "Tim", alreadyGreeted: true))
// Prints "Hello again, Tim!"



func greet(person: String) {
    print("Hello, \(person)!")
}
greet(person: "Dave")
// Prints "Hello, Dave!"



func minMax(array: [Int]) -> (min: Int, max: Int) {
    var currentMin = array[0]
    var currentMax = array[0]
    for value in array[1..<array.count] {
        if value < currentMin {
            currentMin = value
        } else if value > currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
```
## 参数标签、名字


每个函数的参数都有一个参数标签(argument label)和参数名字(parameter name)。参数标签用于外部调用函数时使用，而参数名字则用于函数内部实现。默认情况下，如果不指定参数名字，参数名字将与参数标签保持一致：
```swift
func someFunction(argumentLabel parameterName: Int) {
    // In the function body, parameterName refers to the argument value
    // for that parameter.
}


func greet(person: String, from hometown: String) -> String {
    return "Hello \(person)!  Glad you could visit from \(hometown)."
}
print(greet(person: "Bill", from: "Cupertino"))
// Prints "Hello Bill!  Glad you could visit from Cupertino."


func someFunction(firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}
someFunction(firstParameterName: 1, secondParameterName: 2)
```

---

如果不想给参数标签命名，也可以用下划线代替，这样函数调用传入参数时就不用指定标签：
```swift
func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
    // In the function body, firstParameterName and secondParameterName
    // refer to the argument values for the first and second parameters.
}
someFunction(1, secondParameterName: 2)

```

---

此外可以指定参数的默认参数：
```swift
func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
    // If you omit the second argument when calling this function, then
    // the value of parameterWithDefault is 12 inside the function body.
}
someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6
someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12
```

---

如果在参数后加上...，表示函数可以接受0～多个这种类型的参数(variadic parameter)，提供了更高的灵活性：
```swift
func arithmeticMean(_ numbers: Double...) -> Double {
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
arithmeticMean(1, 2, 3, 4, 5)
// returns 3.0, which is the arithmetic mean of these five numbers
arithmeticMean(3, 8.25, 18.75)
// returns 10.0, which is the arithmetic mean of these three numbers
```

---

默认情况下函数参数都是只读的。如果要在函数内部修改参数的值，可以加上inout属性：
```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// Prints "someInt is now 107, and anotherInt is now 3"
```
注意，调用时inout修饰的参数需要用&修饰。inout参数不能拥有默认参数，也不能用于修饰variadic parameter。
## 函数类型


默认情况下，函数不写明返回类型即代表着返回void类型：
```swift
func printHelloWorld() {
    print("hello, world")
}
```
可以将函数当作变量使用，一个变量可以先后被多个函数赋值：
```swift
func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}
func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {
    return a * b
}

var mathFunction: (Int, Int) -> Int = addTwoInts
print("Result: \(mathFunction(2, 3))")
// Prints "Result: 5"

mathFunction = multiplyTwoInts
print("Result: \(mathFunction(2, 3))")
// Prints "Result: 6"
```
也可以将函数当作其他函数的参数使用：
```swift
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
printMathResult(addTwoInts, 3, 5)
// Prints "Result: 8"
```
还可以将函数当作其他函数的返回值：
```swift
func stepForward(_ input: Int) -> Int {
    return input + 1
}
func stepBackward(_ input: Int) -> Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return
    
    backward ? stepBackward : stepForward
}

var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the stepBackward() function


print("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// 3...
// 2...
// 1...
// zero!
```
## 嵌套函数
函数可以定义在其他函数中：
```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
var currentValue = -4
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero now refers to the nested stepForward() function


while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("zero!")
// -4...
// -3...
// -2...
// -1...
// zero!
```
# 闭包(Closures)
## 一般形式
闭包格式如下：
```swift
{ (parameters) -> return type in
    statements
}
```
例如定义数组排序规则：
```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
```
由于Swift的自动类型推导，上述参数、返回类型都不需要显式地写出，由此括号也可以被省略：
```swift
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
```
倘若还想要更缩略，还有两种方式：

- 使用shorthand argument，通过$0, $1, $2...的形式表示参数个数，由此能省去in关键字
- 使用运算符方法，不过必须是Swift能够识别并且推断得出类型的符号
```swift
reversedNames = names.sorted(by: { $0 > $1 } )

reversedNames = names.sorted(by: >)
```
## 尾闭包
如果想将闭包传递给函数作为最后一个参数，并且这个闭包很长，可以考虑使用尾闭包。尾闭包写起来更加精炼，调用时不用写函数标签：
```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // function body goes here
}

// Here's how you call this function without using a trailing closure:

someFunctionThatTakesAClosure(closure: {
    // closure's body goes here
})

// Here's how you call this function with a trailing closure instead:

someFunctionThatTakesAClosure() {
    // trailing closure's body goes here
}


reversedNames = names.sorted { $0 > $1 }
```
```swift
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]
let numbers = [16, 58, 510]
let strings = numbers.map { (number) -> String in
    var number = number
    var output = ""
    repeat {
        output = digitNames[number % 10]! + output
        number /= 10
    } while number > 0
    return output
}
// strings is inferred to be of type [String]
// its value is ["OneSix", "FiveEight", "FiveOneZero"]
```
## 捕获值(Capturing Values)


看以下例子：
```swift
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```
内函数incrementer()并没有定义任何参数，但是却能访问、修改runningTotal和amount两个变量。这是因为它通过捕获机制，从外函数makeIncrementer()中获取到了这两个变量的引用。

此处捕获变量的引用，主要有两个好处：

- 保证两个变量不会消失
- 保证incrementer()被调用时，runningTotal是可用的


然而需要注意，如果值不会被闭包修改，Swift可能会出于性能优化目的，选择捕获值的拷贝而非引用。

以下是完整的调用例子，注意如果声明了第二个incrementer时，内部的runningTotal是和第一个incrementer独立的，因此两个incrementer并不会相互影响：
```swift
let incrementByTen = makeIncrementer(forIncrement: 10)

incrementByTen()
// returns a value of 10
incrementByTen()
// returns a value of 20
incrementByTen()
// returns a value of 30



let incrementBySeven = makeIncrementer(forIncrement: 7)
incrementBySeven()
// returns a value of 7
incrementByTen()
// returns a value of 40
```
不过，由于函数和闭包都是引用类型，因此如果将上述incrementer赋值给另一个变量，不会改变内部的runningTotal，因为实际上他们调用的是同一个方法：
```swift
let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()
// returns a value of 50

incrementByTen()
// returns a value of 60
```
## 逃逸闭包(Escaping Closures)


如果一个闭包作为参数被传递给函数，但却在函数返回之后才被调用，就称这个闭包为逃逸闭包。此时，需要添加为闭包添加@escaping关键字，表示这个闭包需要逃逸，否则就会在被调用之前，随着外围函数生命周期结束而被一起销毁。

以下例子中，completionHandler访问了函数作用域外的数组completionHandlers，因此数组内的闭包有可能在函数返回后被执行：
```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```
## 自动闭包


调用时不用指定参数，简化调用时的符号；并且可以人为地决定闭包的执行时机：

原始版：
```swift
var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
let customerProvider = { customersInLine.remove(at: 0) }
print(customersInLine.count)
// Prints "5"

print("Now serving \(customerProvider())!")
// Prints "Now serving Chris!"
print(customersInLine.count)
// Prints "4"

// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: { customersInLine.remove(at: 0) } )
// Prints "Now serving Alex!"
```
使用自动闭包：注意调用时customer参数自动被转化为了闭包：
```swift
// customersInLine is ["Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
// Prints "Now serving Ewa!"
```
自动闭包和逃逸两个参数可以同时作用：
```swift
// customersInLine is ["Barry", "Daniella"]
var customerProviders: [() -> String] = []
func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {
    customerProviders.append(customerProvider)
}
collectCustomerProviders(customersInLine.remove(at: 0))
collectCustomerProviders(customersInLine.remove(at: 0))

print("Collected \(customerProviders.count) closures.")
// Prints "Collected 2 closures."
for customerProvider in customerProviders {
    print("Now serving \(customerProvider())!")
}
// Prints "Now serving Barry!"
// Prints "Now serving Daniella!"
```
# 枚举
## 枚举声明
使用enum关键字可以声明一个枚举类型，用于存储一组相关的变量，并且能够保证变量类型安全：
```swift
enum SomeEnumeration {
    // enumeration definition goes here
}


enum CompassPoint {
    case north
    case south
    case east
    case west
}


enum Planet {
    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune
}
```
声明一个enum可以理解为声明了一个新的类型，访问时通过'.'符号实现。注意既可以显示写出enum类型名，也可以不写，由Swift自动推导：
```swift
var directionToHead = CompassPoint.west
irectionToHead = .east
```
## 搭配Switch语句
enum经常与Switch语句搭配。注意Switch语句不能遗漏case，因此所有enum的情况都需要遍及；否则就必须使用default语句，为没有显式遍及到的enum情况提供默认的处理方式：
```swift
directionToHead = .south
switch directionToHead {
case .north:
    print("Lots of planets have a north")
case .south:
    print("Watch out for penguins")
case .east:
    print("Where the sun rises")
case .west:
    print("Where the skies are blue")
}
// Prints "Watch out for penguins"


let somePlanet = Planet.earth
switch somePlanet {
case .earth:
    print("Mostly harmless")
default:
    print("Not a safe place for humans")
}
// Prints "Mostly harmless"
```
## 搭配循环语句
enum可以与循环语句搭配使用：
```swift
enum Beverage: CaseIterable {
    case coffee, tea, juice
}

let numberOfChoices = Beverage.allCases.count
print("\(numberOfChoices) beverages available")
// Prints "3 beverages available"

for beverage in Beverage.allCases {
    print(beverage)
}
// coffee
// tea
// juice
```
## 关联值(Associated Values)
枚举可以指定存储变量的类型，关联对应的变量类型值：
```swift
enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}


var productBarcode = Barcode.upc(8, 85909, 51226, 3)
productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
```
在使用时，可以通过let或者var解析出每个enum case中的关联值，进而判断属于哪一种case。注意如果所有关联值类型相同，可以直接在case名前简写：
```swift
switch productBarcode {
case .upc(let numberSystem, let manufacturer, let product, let check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."


switch productBarcode {
case let .upc(numberSystem, manufacturer, product, check):
    print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")
case let .qrCode(productCode):
    print("QR code: \(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."

```
## 原始值(Raw Values)
Swift中的enum可以指定存储的类型，以及每个case的默认原始值：
```swift
enum ASCIIControlCharacter: Character {
    case tab = "\t"
    case lineFeed = "\n"
    case carriageReturn = "\r"
}

```
注意并不需要为每个case显式地赋值。例如以下例子中，由于第一个case已经被赋值为1，而整个enum存储的类型为整数，因此Swift会自动进行推导，将后续的case原始值分别设定为2，3，...：
```swift
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}

let earthsOrder = Planet.earth.rawValue
// earthsOrder is 3
```
而String类型的原始值就是String本身：
```swift
enum CompassPoint: String {
    case north, south, east, west
}

let sunsetDirection = CompassPoint.west.rawValue
// sunsetDirection is "west"
```

---

可以利用原始值构造一个case。注意这样的构造可能会失败，因为输入的原始值不能保证得到一个有效的case：
```swift
let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.uranus


let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \(positionToFind)")
}
// Prints "There isn't a planet at position 11"
```
## 递归枚举
如果某个enum case的关联值也是一个enum，就必须将这个enum case用indirect关键字修饰，或者修饰整个enum本身：
```swift
enum ArithmeticExpression {
    case number(Int)
    indirect case addition(ArithmeticExpression, ArithmeticExpression)
    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}


let five = ArithmeticExpression.number(5)
let four = ArithmeticExpression.number(4)
let sum = ArithmeticExpression.addition(five, four)
let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))
```
递归枚举可以搭配函数使用：
```swift
func evaluate(_ expression: ArithmeticExpression) -> Int {
    switch expression {
    case let .number(value):
        return value
    case let .addition(left, right):
        return evaluate(left) + evaluate(right)
    case let .multiplication(left, right):
        return evaluate(left) * evaluate(right)
    }
}

print(evaluate(product))
// Prints "18"
```
