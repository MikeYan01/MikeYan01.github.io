---
title: C++补充
tags: Notes Computer-Science C++
article_header:
  type: 
  image:
    src: 
---

补充一些容易混淆、概念抽象的C++知识

<!--more-->

## 链接


链接分为内部链接和外部链接。


如果一个名称对于他的编译单元是局部的，并且在链接时不会与其他的编译单元中同样的名字冲突，那么这个名称就拥有内部链接。这个实体有内部链接，他就不会与其他.cpp文件同名的实体冲突。


那么哪些实体拥有内部链接？


1. 静态（static）全局变量，自由函数，友元函数定义
2. 类的定义
3. 内联函数定义
4. Union共用体定义
5. 名字空间的const常量定义
6. 枚举类型定义



一个多文件的程序中，一个实体可以在链接时与其他编译单元交互，那么这个实体就拥有外部链接。


1. 类的非内联函数（包括成员函数和静态类成员函数）的定义
2. 类的静态成员变量的定义
3. 命名空间或全局的非静态的自由函数，非静态变量，非友元函数的定义



有一些名字定义所表示的实体拥有外部链接，这样就意味着他可以跨越编译单元去进行代码的链接。所以，拥有外部链接的实体如果被声明在头文件并且被多个.cpp文件包含,可能就会出现链接冲突错误，因为每个包含这个拥有外部链接实体的.cpp都会分配空间，当多个编译单元链接的时候，连接器就会面对多个相同的名字，无法正常链接到正确的对象。


## 指针传递、值传递、引用传递


- 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作
- 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
- 引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都会通过栈中存放的地址访问主调函数中的实参变量。



```cpp
#include<iostream>
using namespace std;

//值传递
 void change1(int n){
    cout<<"值传递--函数操作地址"<<&n<<endl; //显示拷贝的地址而不是源地址 
    n++;
}

//引用传递
void change2(int & n){
    cout<<"引用传递--函数操作地址"<<&n<<endl; 
    n++;
}
 //指针传递
void change3(int *n){
     cout<<"指针传递--函数操作地址 "<<n<<endl; 
    *n=*n+1;
 } 
int main(){
    int n=10;
    cout<<"实参的地址"<<&n<<endl;
    change1(n);
    cout<<"after change1() n="<<n<<endl;
    change2(n);
    cout<<"after change2() n="<<n<<endl;
    change3(&n);
    cout<<"after change3() n="<<n<<endl;
    return true;
}

实参的地址0x7ffee9a7a9b8
值传递--函数操作地址0x7ffee9a7a96c
after change1() n=10
引用传递--函数操作地址0x7ffee9a7a9b8
after change2() n=11
指针传递--函数操作地址 0x7ffee9a7a9b8
after change3() n=12
```


## const与static


### const


**const的背景：**


C和C语言有一个很常见的预处理指令 `#define variablename variablevalue` 可以很方便地进行参数的调整与修改，增强代码可读性，提升程序的执行效率。然而预处理语句有个比较致命的缺点，即，只是简单进行值替代，缺乏类型的检测机制。这样预处理语句就不能享受C严格类型检查的好处，从而可能成为引发一系列错误的隐患。const推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。


**const的特点：**


1. 以const修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。
2. const避免意义模糊的数字出现，很方便地进行参数的调整和修改。
3. C++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的运行效率也很高
4. const定义也像一个普通的变量定义一样，编译器会对它进行类型的检测，消除了预定义语句的隐患。



**const的几种使用场景：**


1. const用于指针的两种情况分析

    ```cpp
    int const *a; 　//a可变，*a不可变
    int* const a; 　//a不可变，*a可变 



    char const *ptr; // non-constant pointer to a constant character; cannot change the value by pointer, by can change the pointer itself

    char* const ptr; // a constant pointer to non-constant character

    const char* const ptr; // a constant pointer to constant character
    ```

    分析：const是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，`int const` 限定 `*a`，不限定`a`；`int* const a` 限定`a`，不限定`*a`。
    如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

2. const限定函数的传递值参数

    ```cpp
    void fun(const int var);
    ```

    分析：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。不过，更好的写法是在函数的内部进行限定，对外部调用者屏蔽，以免引起困惑。比如可改写如下：

    ```cpp
    void fun(int var) {
        const int & varalias = var;

        varalias ....

        .....
    }
    ```

3. 限定函数的值型返回值

    ```cpp
    const int fun1(); 

    const myclass fun2();
    ```

    分析：上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。

4. 常量普通对象/取地址对象

    此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。

5. const限定类的成员函数

    ```cpp
    class classname {
        public:

        int fun() const;

        .....

    }
    ```

    注意：采用此种const后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const，因为const已经成为类型信息的一部分。
    
    - 获得能力：可以操作常量对象。
    - 失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。



### static


**static的两大作用：**


1. 控制存储方式
引入static是为了告知编译器，将变量存储在程序的静态存储区而非栈空间内。
默认情况下，函数内部定义的变量，编译器为它在栈内分配空间，函数执行结束时栈空间也会被释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？
最容易想到的方法是定义一个全局的变量，但全局变量的缺点是破坏了此变量的访问范围，因此C++中引入了static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的访问范围不变。
2. 控制可见性与链接类型
static还会把变量的可见范围限制在编译单元中，使它成为一个内部链接，这一点主要是针对全局变量而言。



**类中的static成员变量/成员函数：**


需求：


1. 需要在一个类的各个对象间交互，即需要一个数据对象为整个类而非某个对象服务。
2. 力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。



类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。


注意：


- 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 `::` 来重新声明静态变量从而对它进行初始化
- 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数；普通成员函数则可以任意访问。



## 虚函数


### 虚函数 vs 纯虚函数


C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现，并且允许用基类的指针来调用子类的这个函数。子类可以重写父类的虚函数实现子类的特殊化。


```cpp
class A {
    public:

    virtual void out2(string s) {
        cout<<"A(out2):"<<s<<endl;
    }
};
```


C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。


C++中的纯虚函数也是一种“运行时多态”，但它更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。


```cpp
class A {
    public:
    virtual void out1(string s)=0;
    
};
```


### 动态绑定与虚函数表


- 虚表是一个指针数组，每个元素对应类中的一个虚函数的函数指针。


- 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

- 为了指定对象的虚表，每个对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`__vptr`，用来指向虚表。


动态绑定：在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。引用（或指针）既可以指向基类对象也可以指向派生类对象。


虚函数表实现动态绑定：

![dynamic-binding.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/C++/dynamic-binding.png)

- 类 A 包括两个虚函数，故 A vtbl 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
- 类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 B vtbl 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
- 类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 C vtbl 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。



最后，非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。


## 类的声明与构造


### 类声明后默认有哪些东西


```cpp
class Empty {
    public:
    Empty(); // 缺省构造函数

    Empty( const Empty& ); // 拷贝构造函数

    ~Empty(); // 析构函数

    Empty& operator=( const Empty& ); // 赋值运算符

    Empty* operator&(); // 取址运算符

    const Empty* operator&() const; // 取址运算符 const

};
```


注意，C++默认生成的函数，只有在被需要的时候，才会产生。即当我们定义一个类，而不创建类的对象时，就不会创建类的构造函数、析构函数等。


### 构造函数和析构函数


构造函数不能为虚函数，而析构函数可以且常常是虚函数。


**构造函数：**


1. 存储空间角度

    虚函数对应一个虚函数表vtable，这个vtable其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过vtable来调用，可是对象还没有实例化，也就是内存空间还无法找到vtable

2. 多态角度
　
    虚函数主要是用于实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。



**析构函数：**


析构函数的任务是释放内存，因此它必须确切知道被释放的对象的类型。


必须声明为虚函数的情况：基类指针指向子类对象的情况下，在基类销毁时，只会调用基类的析构函数，而不调用子类的析构函数，从而导致内存泄漏，所以需要虚函数机制来帮助系统识别需要释放哪些资源。


如果一个类是作为基类使用，那么他的虚构函数一定要是虚的；但是其子类或者子子类可以的析构函数可以是虚函数，也可以不是虚函数。


## 内存管理


### new vs malloc，delete vs free


总体而言：


- new和delete更好地适配了面向对象编程，也更加易于使用
- new和delete是C的运算符，而malloc和free是C和C的库函数，二者不能混用，尤其是在面向对象编程的场景下



**new和malloc的差别：**


1. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。那么new是否能在堆上动态分配内存？这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
2. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void _ ，需要通过强制类型转换将void_指针转换成我们需要的类型。
3. new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
4. 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
5. 使用new给对象分配内存时，会调用对象的构造函数，而free不会。具体来说：
   - 调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象
   - 编译器运行相应的构造函数以构造对象，并为其传入初值
   - 对象构造完成后，返回一个指向该对象的指针



**delete和free的区别**


1. free只是告诉操作系统回收某块内存，而delete会先调用类的析构函数，然后才告诉操作系统回收内存。具体来说：
   - 调用对象的析构函数
   - 编译器调用operator delete(或operator delete[])函数释放内存空间
2. 调用free的时候，传入指针的类型以及它所指的内存的容量事先都是知道的，因此可以直接free；但是delete不行，尤其是delete一个普通变量/数组时，要注意delete和delete []的差别，如果对数组回收内存时漏了括号，就只回收了数组首地址对应的内存，后面的对象都被遗漏了，造成内存泄漏



### 深拷贝浅拷贝


- 浅拷贝：增加了一个指针指向已经存在的内存
- 深拷贝：增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存



在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针或者引用时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以此时必须采用深拷贝。


深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，涉及到其他资源（如堆、文件、系统等）的指针或引用时，必须要用深拷贝。


## C++数据结构(STL)


### vector


在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，有两个概念，一个是实际的size()，表示vector内有几个元素；而capacity（）表示目前分配的内存最多能容纳多少个元素，当超过capacity会扩容；但是如果resize()大改小，capacity是不变的


### list


每一个结点都包括一个信息块Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。


### deque


功能上合并了vector和list，随机访问方便，即支持[ ]操作符和vector.at()，在内部方便的进行插入和删除操作，可在两端进行push、pop


deque由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。


### 两种map


unordered_map：基于哈希表
map：基于红黑树


### 两种set


unordered_set：基于哈希表
set：基于红黑树


## 模版


模板是泛型编程的基础，允许函数和类使用泛型进行操作，因此一个函数或类可以在许多不同的数据类型上工作，而不需要为每个类型重写。


```cpp
template <typename type> ret-type func-name(parameter list)
{
   // 函数的主体
}
```


type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。


```cpp
template <typename T>
inline T const& Max (T const& a, T const& b) { 
    return a < b ? b:a; 
}
```
