---
title: LeetCode 1-50
tags: LeetCode Algorithms
article_header:
  type: 
  image:
    src: 
---

LeetCode Problems 1-50.

<!--more-->

## 1. Two Sum

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].


Input: nums = [3,2,4], target = 6
Output: [1,2]


Input: nums = [3,3], target = 6
Output: [0,1]
```

---

我们需要保证`nums[i]`和`target - nums[i]`都在数组中，因此使用hash map存储循环遍历时每个数`nums[i]`以及下标`i`的值，并检查`target - nums[i]`是否也在map中，如果存在，就可以直接提取两个数的位置得到结果。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return new int[] {};
        }
        
        int[] result = new int[2];

        // <Element, Index>
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                result[0] = i;
                result[1] = map.get(target - nums[i]);
                return result;
            }
            map.put(nums[i], i);
        }
        
        return result;
    }
}
```

## 2. Add Two Numbers

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.


Input: l1 = [0], l2 = [0]
Output: [0]


Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

---

加法运算是一个从低位到高位的循环过程，只要下列3个条件之一满足，就会一直持续下去：

- 第一个数某位不为空

- 第二个数某位不为空

- 进位不为0

因此我们创建一个新链表，按照上述条件，对`l1`和`l2`逐位计算相加，得到结果后创建一个新节点插入到链表中。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }

        ListNode dummyHead = new ListNode(0); // dummy head of new list
        ListNode cur = dummyHead; // traverse new list

        int carry = 0;

        // still have digits
        while (l1 != null || l2 != null || carry != 0) {
            int val = 0;

            int val1 = l1 != null ? l1.val : 0;
            int val2 = l2 != null ? l2.val : 0;

            val = (val1 + val2 + carry) % 10;
            carry = (val1 + val2 + carry) / 10;
            
            // insert a new node
            cur.next = new ListNode(val); 
            cur = cur.next;

            // move pointers forward
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        
        return dummyHead.next;
    }
}
```

## 3. Longest Substring Without Repeating Characters

Given a string `s`, find the length of the longest substring without repeating characters.

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.


Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.


Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

---

我们需要一个map记录每个字符最后一次出现的位置。由于`s`中的字符已经确定是英文字母或者符号，因此可以使用定长数组模拟map，提高运行效率。

定义两个指针`begin`和`end`，`begin`指向最长不重复子串起点，尾指针用于遍历`s`，判断当前字符是否于map中。我们的目标就是尾指针完成遍历后，通过两个指针的最大距离差值，得到最长的不重复子串长度。

遍历时需要注意，在遇到重复字符时，`begin`有两种更新方式：

- 这个字符上一次出现位置的后面（+1），这是满足不重复的前提下的最小取值

- 保持不变，因为有可能这个重复字符上一次出现的位置相当靠前，在[map[currentChar] + 1, begin]中间出现了其他的重复字符

具体选择哪种方式更新，只需比较当前`begin`和上一次出现位置+1的大小。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        }
        
        char[] array = s.toCharArray();

        int begin, end = 0; // two pointers to mark the longest substring
        int result = 0; // longest substring's length
        
        int[] map = new int[128]; // <Character, Index>
        Arrays.fill(map, -1);

        for (begin = 0, end = 0; end < s.length(); end++) {
            char currentChar = array[end];
            
            // if this is a repeating character, we either reset begin index to last appearance index + 1 to avoid duplicate
            // or remains unchanged. It is possible that [map[currentChar] + 1, begin] contains duplicate characters
            if (map[currentChar] >= 0) {
                begin = Math.max(begin, map[currentChar] + 1);
            }
            
            // update current character's last position index
            map[currentChar] = end;
            
            // update result
            result = Math.max(result, end - begin + 1);
        }
        return result;
    }
}
```

## 4. Median of Two Sorted Arrays

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.


Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

---

对于一个有序数组，我们做一次分割，将数组分割为两半部分，则数组中位数为下半部分最大值与上半部分最小值的平均值。这种取法的前提是两半部分具有相同的元素值。当数组中有偶数个元素时，分割很容易；而当有奇数个元素时，我们尝试将实际的中位数`mid`一分为二，这样两部分都有了这个`mid`，数组的中位数仍然可以用`(mid + mid) / 2 = mid`得到。

对于一个有`N`个元素的数组，如果定义分割左侧的数为`L`，右侧的数为`R`，则它们可以表示为：

```
L = nums[(N - 1) / 2]
R = nums[N/2]
mid = (L + R) / 2
```

现在，假设为元素之间的间隔也增加下标。例如：

```
[6 9 13 18]  ->   [# 6 # 9 # 13 # 18 #]    (N = 4)
position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)
          
[6 9 11 13 18]->   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)
position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)
```

易得知，总共有`2N + 1`个下标位，并且分割的位置一定在下标为`N`处。因此仍然有

```
index(L) = (N - 1) / 2
index(R) = N / 2
```

至此，我们完成了单个数组的推导。扩展到两个有序数组时，我们可以总结出：

- 一共有`2M + 2N + 2`个下标位
- 需要2个切割点，下标设定为`C1`和`C2`
- 切割的左侧和右侧总共都有`M + N`个元素

假设`nums2`是长度较短的数组，并且切割点的下标为`C2 = K`，则`nums1`的切割点下标为`C1 = M + N - K`。完成这两次切割后，我们可以得到切割点附近的四个下标：

```
L1 = nums1[(C1 - 1) / 2]
R1 = nums1[C1/2]
L2 = nums2[(C2 - 1) / 2]
R2 = nums2[C2/2]
```

为了保证我们的切割是合理的，我们需要保证：

```
L1 <= R1 
L1 <= R2
L2 <= R1
L2 <= R2
```

显然，第1、4个条件是肯定满足的，因此只有中间两个条件满足时，我们才能得到正确的划分。此时，我们可以引用二分搜索。如果`L1 > R2`，说明`nums1`中的切割点取的过大，需要缩小，换言之，我们可以调整`nums2`中的切割点，使其变大并超过`nums1`中的切割点；而如果`L2 > R1`，说明`nums2`中的切割点取的过大，缩小即可。完成切分点的选取后，选取两个子数组相应的最大最小值取平均，即可得到最终答案。

需要注意的是，切割点的下标有可能会发生数组越界。只需假设数组两端各自存在一个极值，当切割点越界时自动赋极值即可解决。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        
        // make sure nums2 is the smaller array
        if (m < n) {
            return findMedianSortedArrays(nums2, nums1);
        }

        int low = 0, high = n * 2;
        while (low <= high) {
            int cut2 = (low + high) / 2;
            int cut1 = m + n - cut2;

            // avoid boundary exception
            double L1 = (cut1 == 0) ? Integer.MIN_VALUE : nums1[(cut1-1)/2];
            double L2 = (cut2 == 0) ? Integer.MIN_VALUE : nums2[(cut2-1)/2];
            double R1 = (cut1 == m * 2) ? Integer.MAX_VALUE : nums1[(cut1)/2];
            double R2 = (cut2 == n * 2) ? Integer.MAX_VALUE : nums2[(cut2)/2];

            if (L1 > R2) {
                // nums1's lower half is too big; need to move C1 left (C2 right)
                low = cut2 + 1;
            } else if (L2 > R1) {
                // nums2's lower half too big; need to move C2 left.
                high = cut2 - 1;
            } else {
                // Otherwise, that's the right cut.
                return (Math.max(L1, L2) + Math.min(R1, R2)) / 2;
            }
        }
        return -1;
    }
}
```

## 5. Longest Palindromic Substring

Given a string `s`, return the longest palindromic substring in `s`.

```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.


Input: s = "cbbd"
Output: "bb"
```

遍历每一个字符，每一个字符都向两侧延展，如果新延展得到的两个字符仍然相同则继续延展，以此计算能延展的最大长度

考虑到回文字符串的长度有两种可能，需要按照奇偶性进行两次延展判断。

```java
class Solution {
    private int startIndex = 0, maxLen = 0;
    
    private void checkPalindrome(char[] array, int left, int right) {
        while (left >= 0 && right <= array.length - 1 && array[left] == array[right]) {
            left--;
            right++;
        }

        // update maxLen = (right - 1) - (left + 1) + 1 = right - left - 1
        if (maxLen < right - left - 1) {
            maxLen = right - left - 1;
            startIndex = left + 1;
        }
    }

    public String longestPalindrome(String s) {
        if (s.length() <= 1) return s;

        char[] array = s.toCharArray();
        for (int i = 0; i < array.length - 1; i++) {
            checkPalindrome(array, i, i); // assume odd length
            checkPalindrome(array, i, i+1); // assume even length
        }
        
        return s.substring(startIndex, startIndex + maxLen);
    }
}
```

## 6. Zigzag Conversion

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

```
P   A   H   N
A P L S I I G
Y   I   R
```

And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

```java
string convert(string s, int numRows);
```

```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I


Input: s = "A", numRows = 1
Output: "A"
```

---

根据`numRows`的长度建立等长的StringBuilder数组，每一行对应一个StringBuilder。按照“竖直向下——斜向右上”的顺序不断向当前行的StringBuilder添加字符串中的字符即可。输出时，要对StringBuilder进行格式转化。

```java
class Solution {
    public String convert(String s, int numRows) {
        int len = s.length();

        // every row is a StringBuilder
        StringBuilder[] sb = new StringBuilder[numRows];
        for (int i = 0; i < numRows; i++) {
            sb[i] = new StringBuilder();
        }

        // index to traverse the whole string
        int index = 0;
        while (index < len) {
            // vertically down
            for (int i = 0; i < numRows && index < len; i++) {
                sb[i].append(s.charAt(index++));
            }
            
            // obliquely up (not include the first and last row)
            for (int i = numRows - 2; i >= 1 && index < len; i--) {
                sb[i].append(s.charAt(index++));
            }
        }

        // append all rows of result
        for (int i = 1; i < numRows; i++) {
            sb[0].append(sb[i]);
        }
        
        return sb[0].toString();
    }
}
```

## 7. Reverse Integer

Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

```
Input: x = 123
Output: 321


Input: x = -123
Output: -321


Input: x = 120
Output: 21
```

---

通过整除反向提取每一位数。为了预防范围溢出，需要在每一次提取后进行一次溢出判断。

```java
class Solution {
    public int reverse(int x) {
        long result = 0;

        while (x != 0) {
            // obtain the last bit
            result = result * 10 + x % 10; 
            x /= 10;
            
            // overflow check
            if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {
                return 0;
            }
        }
        return (int)result;
    }
}
```

## 8. String to Integer (atoi)

Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).

The algorithm for `myAtoi(string s)` is as follows:

1. Read in and ignore any leading whitespace.
2. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.
4. Convert these digits into an integer (i.e. "123" -> 123, "0032" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).
5. If the integer is out of the 32-bit signed integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2<sup>31</sup> should be clamped to -2<sup>31</sup>, and integers greater than 2<sup>31</sup> - 1 should be clamped to 2<sup>31</sup> - 1.
6. Return the integer as the final result.

```
Input: s = "42"
Output: 42
Explanation: The underlined characters are what is read in, the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "42" ("42" is read in)
           ^
The parsed integer is 42.
Since 42 is in the range [-231, 231 - 1], the final result is 42.



Input: s = "   -42"
Output: -42
Explanation:
Step 1: "   -42" (leading whitespace is read and ignored)
            ^
Step 2: "   -42" ('-' is read, so the result should be negative)
             ^
Step 3: "   -42" ("42" is read in)
               ^
The parsed integer is -42.
Since -42 is in the range [-231, 231 - 1], the final result is -42.



Input: s = "4193 with words"
Output: 4193
Explanation:
Step 1: "4193 with words" (no characters read because there is no leading whitespace)
         ^
Step 2: "4193 with words" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "4193 with words" ("4193" is read in; reading stops because the next character is a non-digit)
             ^
The parsed integer is 4193.
Since 4193 is in the range [-231, 231 - 1], the final result is 4193.
```

---

流程分为三步：

1. 去除字符串开头的空格
2. 判断是否存在正负号
3. 判断是否为数字。如果是数字，更新运算结果，并检查当前结果是否超出整数范围；如果不是数字，则返回当前结果

```java
class Solution {
    public int myAtoi(String str) {
        // trim leading blank space
        str = str.trim();
        if (str.length() == 0) {
            return 0;
        }

        // detect sign
        char firstChar = str.charAt(0);
        int sign = 1;
        int digitStart = 0; // default no sign char, thus digit start from index 0
        if (firstChar == '+' || firstChar == '-') {
            sign = (firstChar == '+') ? 1 : -1;
            digitStart++;
        }

        // add digits
        long sum = 0;
        for (int i = digitStart; i < str.length(); i++) {
            char current = str.charAt(i);

            // non-digit, return sum immediately
            if (current < '0' || current > '9') {
                return (int)sum * sign;
            }
            
            // continue adding current digit
            sum = sum * 10 + current - '0';

            // overflow checking
            if (sign == 1 && sum > Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }
            if (sign == -1 && -sum < Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
        }
        return (int)sum * sign;
    }
}
```

## 9. Palindrome Number

Given an integer `x`, return true if `x` is palindrome integer.

An integer is a palindrome when it reads the same backward as forward.

For example, 121 is a palindrome while 123 is not.

```
Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.


Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.


Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
```

---

将数字反转后与原数字进行比较。注意，不需要完整地将整个数字进行反转，只需要反转一半的数字，并与剩余一半进行比较即可

```java
class Solution {
    public boolean isPalindrome(int x) {
        // exclude negative number and 10's multiple
        if (x < 0 || (x != 0 && x % 10 == 0)) {
            return false;
        }

        int result = 0;
        
        // only need to reverse half of all digits
        while (x > result) {
            result = result * 10 + x % 10;
            x /= 10;
        }
        
        // odd or even length
        return (x == result || x == result / 10); 
    }
}
```

## 10. Regular Expression Matching

Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:

- `'.'` Matches any single character.​​​​
- `'*'` Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".


Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".


Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
```

---

此题需要使用二维动态规划算法。对于`s`和`p`，我们需要从头开始推导出子字符串`s[i]`和`p[j]`的匹配情况，进而推出整个`s`和`p`是否匹配。

解决时，需要对题设条件进行分类讨论：

- 最标准的匹配情况，即`string[i]` = `pattern[j]`，则`dp[i+1][j+1]` = `dp[i][j]`
- pattern中出现了`'.'`，可以匹配string中任意的一个字符，同样有`dp[i+1][j+1]` = `dp[i][j]`
- pattern中出现了`'*'`，需要进一步讨论：
    - 如果`pattern[j-1]` != `string[i]`，说明此时的`'a*'`只能作为空字符串匹配，因此`dp[i+1][j+1]` = `dp[i+1][j-1]`
    - 如果`pattern[j-1]` == `string[i]`, 或是`pattern[j-1]` == `'.'`，即在'*'之前的一个字符也能够匹配上，则：
        - 如果`'*'`匹配空字符串，则`dp[i+1][j+1]` = `dp[i+1][j-1]`
        - 如果`'*'`匹配一个字符，则`dp[i+1][j+1]` = `dp[i+1][j]`
        - 如果`'*'`匹配多个字符，则`dp[i+1][j+1]` = `dp[i][j+1]`

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        
        // s and p are both empty, so they can match
        dp[0][0] = true;

        // pattern cannot start with '*'
        if (p.length() > 0 && p.charAt(0) == '*') {
            return false;
        }

        // '*' match
        for (int j = 0; j < p.length(); j++) {
            if (p.charAt(j) == '*' && dp[0][j-1]) {
                dp[0][j+1] = true;
            }
        }
    
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < p.length(); j++) {
                // regular matching, or '.' matching
                if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') {
                    dp[i+1][j+1] = dp[i][j];    
                } else if (p.charAt(j) == '*') {
                    // * can only be matched as empty char
                    if (s.charAt(i) != p.charAt(j-1)) {
                        dp[i+1][j+1] = dp[i+1][j-1];
                    }
                    
                    // * can be matched as 0, 1 or multiple chars
                    if (s.charAt(i) == p.charAt(j-1) || p.charAt(j-1) == '.') {
                        dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1]; 
                    }
                }
            }
        }
        
        return dp[s.length()][p.length()];
    }
}
```

## 11. Container With Most Water

You are given an integer array height of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`<sup>th</sup> line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.


Input: height = [1,1]
Output: 1
```

---

问题转化为判断两个横坐标之间能够围成的最大面积。定义两个指针，一个指向数组头向尾遍历，另一个指向数组尾向头遍历。在遍历之前不断计算当前能围成的最大面积，并且向着可能进一步增大面积的方向移动指针。

```java
class Solution {
    public int maxArea(int[] height) {
        if (height == null || height.length <= 1) {
            return 0;
        }

        int left = 0, right = height.length - 1;
        int result = 0, current = 0; // max area, current area

        while (left < right) {
            current = (right - left) * Math.min(height[left], height[right]);
            result = Math.max(result, current);

            // keep the higher edge, and try to increase the other edge
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return result;
    }
}
```

## 12. Integer to Roman

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

- I can be placed before V (5) and X (10) to make 4 and 9. 
- X can be placed before L (50) and C (100) to make 40 and 90. 
- C can be placed before D (500) and M (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

```
Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.


Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.


Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

---

非常无聊的题目，直接穷举`nums`范围内各个基数单位，不断叠加上当前的最大基数对应的罗马字符。

```java
class Solution {
    public String intToRoman(int num) {
        int[] value = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] roman = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < value.length; i++) {
            while (num >= value[i]) {
                sb.append(roman[i]);
                num = num - value[i];
            }
        }
        
        return sb.toString();
    }
}
```

## 13. Roman to Integer

Given a roman numeral, convert it to an integer.

```
Input: s = "III"
Output: 3
Explanation: III = 3.


Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.


Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

---

遇到可能包含歧义的字母（M, X, V等）时，额外判断后一个字母明确具体数字即可。

```java
class Solution {
    public int romanToInt(String s) {
        if (s.length() == 0) {
            return 0;
        }

        int i = 0;
        int len = s.length();
        int result = 0;

        while (i < len) {
            char c = s.charAt(i); // current character
            char nextChar = '.'; // if there is a next character
            if (i != len - 1) {
                nextChar = s.charAt(i+1);
            }

            // need to check IV and IX
            if (c == 'I') {
                if (nextChar == 'V') {
                    result += 4;
                    i += 2;
                } else if (nextChar == 'X') {
                    result += 9;
                    i += 2;
                } else {
                    result += 1;
                    i += 1;
                }
            }

            else if (c == 'V') {
                result += 5;
                i += 1;
            }

            // need to check XL and XC
            else if (c == 'X') {
                if (nextChar == 'L') {
                    result += 40;
                    i += 2;
                } else if (nextChar == 'C') {
                    result += 90;
                    i += 2;
                } else {
                    result += 10;
                    i += 1;
                }
            }

            else if (c == 'L') {
                result += 50;
                i += 1;
            }

            // need to check CD and CM
            else if (c == 'C') {
                if (nextChar == 'D') {
                    result += 400;
                    i += 2;
                } else if (nextChar == 'M') {
                    result += 900;
                    i += 2;
                } else {
                    result += 100;
                    i += 1;
                }
            }

            else if (c == 'D') {
                result += 500;
                i += 1;
            }

            else if (c == 'M') {
                result += 1000;
                i += 1;
            }
        }
        return result;
    }
}
```

## 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

```
Input: strs = ["flower","flow","flight"]
Output: "fl"


Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```

---

初始假定第一个词就是LCS。为了验证假设，我们需要逐个检查所有后续字符串，确定最开始的LCS也是后面字符串的前缀。如果不满足，则删掉LCS的最后一个字符。

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        
        // initialized as the first word of strs
        String result = strs[0];

        for (int i = 0; i < strs.length; i++) {
            // keeps removing the last character until matching the common prefix requirement
            while (strs[i].indexOf(result) != 0) {
                result = result.substring(0, result.length() - 1);
                if (result.length() == 0) {
                    break;
                }
            }
        }
            
        return result;
    }
}
```

## 15. 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j,` `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]


Input: nums = []
Output: []


Input: nums = [0]
Output: []
```

---

先对数组进行排序。

接着设立三个指针`first`, `second`, `third`。`first`负责从数组头遍历至数组尾，在每一次循环中固定`first`，移动头尾指针`two`和`third`，对`nums[first]`、`nums[second]`、`nums[third]`求和判断是否为0。

这题需要最大化利用排序带来的优势，缩短运行时间：

- 检查最小/最大值，跳过一些不必要的检查
- 跳过相邻的重复元素

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        
        int len = nums.length;
        if (len < 3) {
            return result;
        }

        // sort so we can use pointers to quickly sum
        Arrays.sort(nums); 
        
        // skip impossible cases
        if (3 * nums[0] > 0 || 3 * nums[len - 1] < 0) {
            return result;
        }

        for (int first = 0; first < len - 2; first++) {
            // skip if nums[first] is duplicate
            if (first > 0 && nums[first] == nums[first-1]) {
                continue; 
            }
            
            // too big, no need to check subsequent combinations
            if (3 * nums[first] > 0) {
                break; 
            }
            
            // too small, we need to start from a larger nums[first]
            if (nums[first] + 2 * nums[len - 1] < 0) {
                continue;
            }

            int second = first + 1, third = len - 1;
            while (second < third) {
                if (nums[first] + nums[second] + nums[third] == 0) {
                    result.add(Arrays.asList(nums[first], nums[second], nums[third]));

                    // skip nums[second] and nums[third] duplicates
                    while (second < third && nums[second] == nums[second + 1]) {
                        second++;
                    }
                    while (third > second && nums[third] == nums[third - 1]) {
                        third--;
                    }

                    // move pointers
                    second++;
                    third--;
                } else if (nums[first] + nums[second] + nums[third] < 0) {
                    second++;
                } else {
                    third--;
                }
            }
        }
        return result;
    }
}
```

## 16. 3Sum Closest

Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the `sum` is closest to `target`.

Return the sum of the three integers.

You may assume that each input would have exactly one solution.

```
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).


Input: nums = [0,0,0], target = 1
Output: 0
```

---

与前一题思路类似，只是将”恰好等于“改成了”最接近于“。额外加一个变量`tempSum`用于存储当前最接近的和即可。

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int len = nums.length;
        int result = 0;

        // less than three numbers, directly return all num's sum
        if (len <= 3) {
            for (int num : nums) {
                result += num;
            }
            return result;
        }

        // initialized as the sum of first three elements
        result = nums[0] + nums[1] + nums[2];
        
        // sort so we can use pointers to quickly sum
        Arrays.sort(nums);

        for (int first = 0; first < len - 2; first++) {
            // skip if nums[first] is duplicate
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }

            int second = first + 1, third = len - 1;
            while (second < third) {
                int tempSum = nums[first] + nums[second] + nums[third];
                
                // determine if tempSum is equal to target, or try to get tempSum closer to target
                if (tempSum == target) {
                    return tempSum;
                } else if (tempSum < target) {
                    second++;
                } else {
                    third--;
                }

                // update result
                if (Math.abs(target - result) > Math.abs(target - tempSum)) {
                    result = tempSum;
                }
            }
        }
        
        return result;
    }
}
```


## 17. Letter Combinations of a Phone Number

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

```
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]


Input: digits = ""
Output: []


Input: digits = "2"
Output: ["a","b","c"]
```

---

设立一个字符串数组，数组下标0-9分别对应键盘0-9上的字符串。

遍历`digits`的每一位数字，得到这个数字可能对应的所有字母。使用回溯算法，尝试添加每一个字符，再通过深度优先思想添加下一个。以此类推，直到当前的string builder长度等于`digits`长度，表示发掘出了一种组合。

```java
class Solution {
    private List<String> result = new ArrayList<>();
    private final String[] mapping = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return result;
        }
        
        backtrack(new StringBuilder(), digits, 0);
        
        return result;
    }
    
    private void backtrack(StringBuilder current, String digits, int index) {
        // find a combination, add to result
        if (current.length() == digits.length()) {
            result.add(current.toString());
            return;
        }
        
        // get all possible letters that are matching with current digit
        int digit = digits.charAt(index) - '0';
        String letters = mapping[digit];
        
        for (char letter: letters.toCharArray()) {
            current.append(letter);
            backtrack(current, digits, index + 1);
            current.deleteCharAt(current.length() - 1);
        }
    }
}
```

## 18. 4Sum

Given an array nums of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a`, `b`, `c`, and `d` are distinct.
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in any order.

```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]


Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

---

4Sum与3Sum的思路类似，仍然是使用多个指针的移动解决问题。使用`first`, `second`两个指针从头到尾遍历整个数组，而`third`, `fourth`两个指针则在`second`的后面，一前一后。

需要注意，在判断极值的时候可能会产生溢出，因此需要考虑int和long之间的转换。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        int len = nums.length;
        if (len < 4) {
            return result;
        }

        // sort so we can use pointers to quickly sum
        Arrays.sort(nums);
        
        // too big or small
        Long potentialMin = (long)4 * nums[0];
        if (potentialMin > target) {
            return result;
        }
        
        Long potentialMax = (long)4 * nums[len - 1];
        if (potentialMax < target) {
            return result;
        }

        for (int first = 0; first < len - 3; first++) {
            // skip if nums[first] is duplicate
            if (first > 0 && nums[first] == nums[first-1]) {
                continue;
            }
            
            // too big, no need to check subsequent combinations
            Long potentialRestFourMin = (long)4 * nums[first];
            if (potentialRestFourMin > target) {
                break;
            }
            
            // too small, we need to start from a larger nums[first]
            Long potentialRestThreeMax = (long)3 * nums[len - 1];
            if (nums[first] + potentialRestThreeMax < target) {
                continue;
            }

            for (int second = first + 1; second < len - 2; second++) {
                // skip if nums[first] is duplicate
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                
                // too big, no need to check subsequent combinations
                Long potentialRestThreeMin = (long)3 * nums[second];
                if (potentialRestThreeMin + nums[first] > target) {
                    break;
                }
                
                // too small, we need to start from a larger nums[second]
                if (nums[first] + nums[second] + 2 * nums[len - 1] < target) {
                    continue;
                }

                int third = second + 1, fourth = len - 1;
                while (third < fourth) {
                    if (nums[first] + nums[second] + nums[third] + nums[fourth] == target) {
                        result.add(Arrays.asList(nums[first], nums[second], nums[third], nums[fourth]));
                        
                        // skip duplicates
                        while (second < len - 2 && nums[second] == nums[second + 1]) {
                            second++;
                        }
                        while (third < fourth && nums[third] == nums[third + 1]) {
                            third++;
                        }
                        while (third < fourth && nums[fourth] == nums[fourth - 1]) {
                            fourth--;
                        }

                        // move pointers
                        third++;
                        fourth--;
                    } else if (nums[first] + nums[second] + nums[third] + nums[fourth] < target) {
                        third++;
                    } else {
                        fourth--;
                    }
                }
            }
        }
        return result;
    }
}
```

## 19. Remove Nth Node From End of List

Given the `head` of a linked list, remove the `n`<sup>th</sup> node from the end of the list and return its head.

![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]


Input: head = [1], n = 1
Output: []


Input: head = [1,2], n = 1
Output: [1]
```

---

引入两个指针，一快一慢，二者之间的下标差为`n`（即`slow`指针指向第1个元素，则`fast`指针指向第`n+1`个元素）。删除节点则只需要调整节点的`next`指针即可。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        
        // slow and fast pointers
        ListNode slow = dummyHead, fast = dummyHead;

        // fast moves n steps ahead
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // move slow and fast together
        while (fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // delete nth node
        slow.next = slow.next.next;

        return dummyHead.next;
    }
}
```

## 20. Valid Parentheses

Given a string s containing just the characters `'(',` `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

```
Input: s = "()"
Output: true


Input: s = "()[]{}"
Output: true


Input: s = "(]"
Output: false
```

---

利用栈的特性，如果遇到左半侧的括号则推入栈中，右半侧的括号则检查是否与当前栈顶元素配对，如果不能配对就返回false，否则配对成功就把栈顶括号弹出。最后确认栈是否为空。

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length() == 0) {
            return true;
        }

        Stack<Character> st = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            // push all left parentheses into stack
            if (c == '(' || c == '[' || c == '{') {
                st.push(c);
            } else if (c == ')' || c == ']' || c == '}') {
                // current right parenthesis must match with top parenthesis in the stack
                if (st.size() == 0) {
                    return false;
                }

                if (c == ')' && st.peek() != '(') {
                    return false;
                } else if (c == ']' && st.peek() != '[') {
                    return false;
                } else if (c == '}' && st.peek() != '{') {
                    return false;
                } else {
                    // successfully matched, pop the top parenthesis
                    st.pop();
                }
            }
        }
        return st.isEmpty();
    }
}
```

## 21. Merge Two Sorted Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]


Input: list1 = [], list2 = []
Output: []


Input: list1 = [], list2 = [0]
Output: [0]
```

第一种方法，比较`l1`和`l2`上的指针当前指向的元素，取较小元素之后的子链表和另一个链表继续进行递归合并。这样能保证每一次比较都优先提取出两个剩余链表的最小值，其余部分的结果也会接在这个最小值之后。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }

        // merge after smaller node
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```

第二种方法，也是比较`l1`和`l2`上的指针当前指向的元素，但不使用递归，而是直接根据大小关系决定排列顺序。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }

        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;

        while (l1 != null && l2 != null) {
            // decide which element to be added to the result list
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        
        // one list reaches the end, add the rest list elements to result
        cur.next = (l2 == null) ? l1 : l2;
        
        return dummyHead.next;
    }
}
```

## 22. Generate Parentheses

Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

```
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]


Input: n = 1
Output: ["()"]
```

---

使用递归策略，优先构造左括号，当左括号个数大于右括号时再构造右括号。

具体代码实现时，可以使用两个变量`left`，`right`跟踪当前左、右括号数量，在递归中将它们与`n`进行比较。

```java
class Solution {
    List<String> result = new ArrayList<>();
    
    public List<String> generateParenthesis(int n) {
        generate("", 0, 0, n);
        return result;
    }

    // left: left parentheses' count
    // right: right parentheses' count
    private void generate(String s, int left, int right, int n) {
        if (right == n) {
            // finish construction
            result.add(s); 
        } else {
            // always prefer to generate left parenthesis first
            if (left < n) {
                generate(s + "(", left + 1, right, n);
            }
            
            // left is greater than right, then generate a right parenthesis
            if (left > right) {
                generate(s + ")", left, right + 1, n);
            }
        }
    }
}
```

## 23. Merge k Sorted Lists

You are given an array of `k` linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6


Input: lists = []
Output: []


Input: lists = [[]]
Output: []
```

---

第一种解法是使用优先队列。优先队列本质上是一种堆，具体使用时可以自定义comparator指定最小堆或是最大堆。由于此题要求从小到大排序，因此需要定义最小堆。

将每一条链表的头元素加入优先队列中。优先级最高的元素就是这些元素里的最小值。将其排序后进行判断，如果该元素的next指针不指向空，则将剩下的链表头元素重新插入优先队列中。

以一个形象一些的方式描述该场景：一位教师正在向一群排队的学生解答问题，每个学生都有多个问题，并且问题的难度有难有易，教师优先回答简单的问题。为保证公平，当前问问题的学生问完一个问题后需要重新排队，排队顺序取决于他下一个问题的难度。

时间复杂度上，如果链表有`N`个节点，则堆的插入、删除操作时间复杂度均为`O(logN)`，总的时间复杂度为`O(NlogN)`。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // override priority queue's comparator in ascending order
        Queue<ListNode> pq = new PriorityQueue<>((ListNode l1, ListNode l2) -> {
            return l1.val - l2.val;
        });

        // add each list's head (smallest) node into the priority queue
        for (ListNode list : lists) {
            if (list != null) {
                pq.offer(list);
            }
        }

        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;

        while (!pq.isEmpty()) {
            // pick out the smallest element from priority queue
            ListNode currentHead = pq.poll();
            cur.next = currentHead;
            cur = cur.next;

            // add its next element into the queue
            if (cur.next != null) {
                pq.offer(cur.next);
            }
        }
        
        return dummyHead.next;
    }
}
```

第二种解法是使用分治策略，将`k`条链表对半分为两组，问题转化为了广义版的merge two sorted lists问题。不断从上而下划分，再由小到大不断两两合并，得到完整的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }

    private ListNode merge(ListNode[] lists, int l, int r) {
        // invalid interval
        if (l > r) {
            return null; 
        }
        
        // interval only has one list group
        if (l == r) {
            return lists[l]; 
        }

        // divide k lists into two groups
        int mid = l + (r - l) / 2;
        ListNode left = merge(lists, l, mid);
        ListNode right = merge(lists, mid + 1, r);

        // merge two "big" lists together
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        
        while (left != null || right != null) {
            // right list is null, or the head of left list is smaller than the one of right list
            if (right == null || (left != null && left.val < right.val)) {
                cur.next = left;
                left = left.next;
            } else {
                cur.next = right;
                right = right.next;
            }
            cur = cur.next;
        }
        
        return dummyHead.next;
    }
}
```

## 24. Swap Nodes in Pairs

Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
Input: head = [1,2,3,4]
Output: [2,1,4,3]


Input: head = []
Output: []


Input: head = [1]
Output: [1]
```

---

使用递归，只提取前两个节点，将剩余节点视为一个整体。

新的头节点`newHead`是原来的第二个节点`head.next`，而原来的头节点`head`指向剩余节点整体（剩余部分的头节点为`head.next.next`）。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        // previous second node now bcomes the head node
        ListNode newHead = head.next; 

        // regard all other nodes as an entity, and the head of this entity is head.next.next
        head.next = swapPairs(head.next.next); 

        // previous head node now becomes the second node
        newHead.next = head;

        return newHead;
    }
}
```

## 25. Reverse Nodes in k-Group

Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.

`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
```

![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]
```

---

假设遍历链表的指针为`cur`，将`cur`移动`k`个节点，获取到`k`个节点就能组成一个节点簇。我们优先递归完成链表后续部分的反转，再来倒转节点簇的`k`个节点。每个节点簇内，我们的核心思想是把原先的第一个节点指向链表后续部分，这样一来这个节点就可以被归到已经逆序的子链表中；而原先节点簇的第二个节点就成为了剩余未逆序部分的头节点。我们需要不断循环`k`次，按照上述流程调整顺序。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) {
            return null;
        }

        // move cur k nodes forward
        ListNode cur = head;
        int count = 0;
        while (cur != null && count != k) {
            count++;
            cur = cur.next;
        }

        // we get k nodes in a group now
        if (count == k) {
            // recursively complete all other nodes first to get the modified sub-list
            cur = reverseKGroup(cur, k);

            // reverse k nodes
            while (count-- > 0) {
                // get the second element among k nodes
                ListNode second = head.next;
                
                // current first element (head) will point to the modified sub-list 
                head.next = cur;

                // previous head has become the head of the modified sub-list
                cur = head;
                
                // previous second element now becomes the new head of the un-reversed part
                head = second; 
            }
            
            // after reverse, the head of the modified sub-list is actually the head of the whole list
            head = cur;
        }
        
        return head;
    }
}
```

## 26. Remove Duplicates from Sorted Array

Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.

Return k after placing the final result in the first k slots of `nums`.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

```
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).


Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

---

从头开始遍历，只要遇到不重复的数时，就覆盖数组的原始值。最后返回的`result`值实际上就是不同数字的个数。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int len = nums.length;
        if (len <= 1) {
            return len;
        }

        int result = 1;
        for (int i = 1; i < len; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[result] = nums[i]; // in-place modification
                result++;
            }
        }
            
        return result;
    }
}
```

## 27. Remove Element

Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The relative order of the elements may be changed.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.

Return `k` after placing the final result in the first `k` slots of `nums`.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.

```
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).


Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
```

---

与上一题一样的思路，遇到值为`val`的元素时跳过，其余仍从头到尾开始覆盖。

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int len = nums.length;

        int result = 0;
        for (int i = 0; i < len; i++) {
            if (nums[i] != val) {
                nums[result] = nums[i]; // in-place modification
                result++;
            }
        }
            
        return result;
    }
}
```

## 28. Implement strStr()

Implement `strStr()`.

Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.

Clarification:

What should we return when `needle` is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's `strstr()` and Java's `indexOf()`.

```
Input: haystack = "hello", needle = "ll"
Output: 2


Input: haystack = "aaaaa", needle = "bba"
Output: -1
```

---

遍历`haystack`中的每一个字符，如果某个字符与`needle`的首字符相同，再检查`haystack`中该字符起的子串是否与`needle`的值相同。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int hLen = haystack.length(), nLen = needle.length();
        
        // needle is an empty string
        if (nLen == 0) {
            return 0; 
        }
        
        // haystack is empty and impossible to contain needle
        if (hLen == 0) {
            return -1; 
        }

        for (int i = 0; i <= hLen - nLen; i++) {
            // current char is equal to needle's first char & substring is equal to needle
            if (haystack.charAt(i) == needle.charAt(0) && haystack.substring(i, i + nLen).equals(needle)) {
                return i;
            }
        }

        return -1;
    }
}
```

## 29. Divide Two Integers

Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator.

The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.

Return the quotient after dividing `dividend` by `divisor`.

Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>, 2<sup>31</sup> − 1]. For this problem, if the quotient is strictly greater than 2<sup>31</sup> - 1, then return 2<sup>31</sup> - 1, and if the quotient is strictly less than -2<sup>31</sup>, then return -2<sup>31</sup>.

```
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = 3.33333.. which is truncated to 3.


Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = -2.33333.. which is truncated to -2.
```

---

此题要求实现除法，并且不能使用乘、除、取模三个符号。大致的思路流程是：

1. 专门处理被除数为`Integer.MIN_VALUE`，`divisor`为-1时的情况，这种时候int形式的结果会发生溢出
2. 将`dividend`和`divisor`都取绝对值
3. 使用指数倍增思想，快速寻找到`dividend`中至少包含几个`divisor`。
4. 决定最终结果的实际符号

为了避免溢出，在第一步处理完特例后，我们最好将`dividend`和`divisor`都转为long格式。

```java
class Solution {
    public int divide(int dividend, int divisor) {
        // corner case
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
        
        long dividendCopy = (long)dividend, divisorCopy = (long)divisor;

        // get rid of sign 
        long a = Math.abs(dividendCopy), b = Math.abs(divisorCopy);
        long result = 0;

        while (a >= b) {
            int x = 0;

            // count how many divisor does the dividend "has"
            while (a >= (b << 1 << x)) {
                x++;
            }
            
            result += 1 << x;
            a -= b << x;
        }

        // determine if dividend and divisor have same sign
        return (dividend > 0) == (divisor > 0) ? (int)result : (int)-result;
    }
}
```

## 30. Substring with Concatenation of All Words

You are given a string `s` and an array of strings `words` of the same length. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.

You can return the answer in any order.

```
Input: s = "barfoothefoobarman", words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoo" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.


Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
Output: []


Input: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
Output: [6,9,12]
```

---

只要`words`中的所有单词拼接得到`s`中的子字符串即可满足题意，单词的顺序并不重要。因此我们只需要关注`words`中每一个单词出现的次数。

此题可以使用两个HashMap解决，一个HashMap用于记录`words`数组中的每一个单词出现的次数；另一个HashMap用于记录当前遍历`s`时的单词已经出现了几次。如果当前遍历的单词是`words`中没有的，或者出现次数已经超过了“应该”出现的次数，则说明不满足题意。

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> result = new ArrayList<>();
        if (words.length == 0) {
            return result;
        }

        // how many times each word is supposed to occur
        Map<String, Integer> expected = new HashMap<>();
        for (String word : words) {
            expected.put(word, expected.getOrDefault(word, 0) + 1);
        }
            
        // each word's length and all words' count
        int len = words[0].length(), count = words.length;
        if (s.length() < count * len) {
            return result;
        }

        for (int i = 0; i < len; i++) {
            for (int j = i; j <= s.length() - count * len; j += len) {
                // how many times every word actually occurs in each substring
                Map<String, Integer> actual = new HashMap<>();

                // iterate from the last
                for (int k = count - 1; k >= 0; k--) {
                    // extract current word
                    String currentWord = s.substring(j + k * len, j + (k + 1) * len);
                    
                    // current word is not supposed to occur
                    if (!expected.containsKey(currentWord)) {
                        break;
                    } else {
                        int occurences = actual.getOrDefault(currentWord, 0) + 1;
                        
                        // can not exceed expected occurences
                        if (occurences > expected.get(currentWord)) {
                            // start right after invalid occurence, as previous choices will include invalid.
                            j += k * len;
                            break;
                        }
                        
                        actual.put(currentWord, occurences);
                        
                        // all words appear
                        if (k == 0) {
                            result.add(j);
                        }
                    }
                }
            }
        }
        return result;
    }
}
```

## 31. Next Permutation

A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

For example, for `arr = [1,2,3]`, the following are considered permutations of arr: `[1,2,3]`, `[1,3,2]`, `[3,1,2]`, `[2,3,1]`.
The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.
- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.
- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.

Given an array of integers nums, find the next permutation of nums.

The replacement must be in place and use only constant extra memory.

```
Input: nums = [1,2,3]
Output: [1,3,2]


Input: nums = [3,2,1]
Output: [1,2,3]

Input: nums = [1,1,5]
Output: [1,5,1]
```

---

一个数组向下一置换演变的趋势总体是从升序演变为降序。

找到下一置换，实际上就是从右到左遍历，先找到破坏升序的第一个数`nums[i]`，再从这个数的右侧（也是从右向左遍历）找到第一个比`nums[i]`大的数`nums[j]`，这两个数进行交换。最后，对下标`i`之后的数需要全部进行反转，因为在经过交换之后，从下标`i`开始一直到结尾都是降序，我们需要将`i + 1`到结尾重新调整为升序，确保不遗漏置换的可能。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        // search from right to left and find the first element to break the ascending order
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i+1]) {
            i--;
        }

        // if there is an element that break the ascending order
        if (i >= 0) {
            int j = nums.length - 1;

            // find the rightmost element which is larger than nums[i]
            while (nums[i] >= nums[j]) {
                j--;
            }
            
            // swap nums[i] and nums[j]
            swap(nums, i, j);
        }
        // reverse all elements after index i
        reverseArray(nums, i + 1, nums.length - 1);
    }

    // swap two nums
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    // reverse part of the array
    private void reverseArray(int[] nums, int i, int j) {
        while (i < j) {
            swap(nums, i++, j--);
        }
    }
}
```

## 32. Longest Valid Parentheses

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

```
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".


Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".


Input: s = ""
Output: 0
```

---

使用栈解决。遍历字符串，如果遇到'('，则将当前下标推入栈中；遇到')'，则将栈顶下标弹出，并讨论。需要注意：

- 栈里存储的下标，实质上指的是“截止到这个下标时，字符串不能组成valid parentheses”。我们最后更新结果时，也是用当前下标与栈顶下标的差值来更新长度，因为这一段差值之间的字符串一定是有效的
- 因为上述设定，栈的初始化需要push一个-1；如果空栈的时候，说明截止至目前的字符串一定是无效的，我们要想找有效字符串只能在此之后寻找


```java
class Solution {
    public int longestValidParentheses(String s) {
        int result = 0;
        
        ArrayDeque<Integer> stack = new ArrayDeque<Integer>();
        
        // the index preceding to potential start of valid parentheses
        stack.push(-1);
        
        for (int i = 0; i < s.length(); i++) {
            char curr = s.charAt(i);
            if (curr == '(') {
                stack.push(i);
            } else {
                // no matter we get valid parentheses or not, we need to pop here
                // if valid, we need to get last index to calculate diff
                // if unvalid, we update with current index
                stack.pop();
                
                if (stack.isEmpty()) {
                    // the stack is empty only if we have an extra ')'. Any further extensions of valid parentheses is impossible
                    // push current index, since it is preceding to potential start of valid parentheses
                    stack.push(i);
                } else {
                    // this may be our longest valid parentheses
                    result = Math.max(result, i - stack.peek());
                }
            }
        }
        
        return result;
    }
}
```

## 33. Search in Rotated Sorted Array

There is an integer array `nums` sorted in ascending order (with distinct values).

Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4


Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1


Input: nums = [1], target = 0
Output: -1
```

---

这一题需要将数组对半划分来看，其中一半一定是有序的，而另一半则在中间某处破坏了升序。因此在使用模型1时，我们无法简单通过比较`nums[mid]`和`target`确定下一轮搜索区间，而是应该比较`nums[left]`、`nums[mid]`和`nums[right]`三者的值，先判断哪一半数组是有序的；之后将`target`放进有序的这一侧进行比较，如果`target`的值介于其中则把区间定为有序的这一侧，反之定为另一侧。

```java
class Solution {
    public int search(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;

            // nums[mid] matches with target, return
            if (nums[mid] == target) {
                return mid;
            }

            // left half is ordered
            if (nums[left] <= nums[mid]) {
                // target is in left half
                if (target >= nums[left] && target <= nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }

            // right half is ordered
            if (nums[mid] <= nums[right]) {
                // target is in right half
                if (target >= nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
}
```

## 34. Find First and Last Position of Element in Sorted Array

Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.

If `target` is not found in the array, return `[-1, -1]`.

You must write an algorithm with `O(log n)` runtime complexity.

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]


Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]


Input: nums = [], target = 0
Output: [-1,-1]
```

---

分别进行左边界搜索和右边界搜索即可。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[] {-1, -1};
        if (nums == null || nums.length == 0) {
            return result;
        }

        // left
        int left = 0, right = nums.length;
        while (left < right) { 
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] >= target) {
                right = mid;
            }
        }
        
        if (left != nums.length && nums[left] == target) {
            result[0] = left;
        }

        // right
        left = 0;
        right = nums.length;
        while (left < right) { 
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        
        if (left != 0 && nums[left - 1] == target) {
            result[1] = left - 1;
        }

        return result;
    }
}
```

## 35. Search Insert Position

Given a sorted array of distinct integers and a `target` value, return the index if the `target` is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

```
Input: nums = [1,3,5,6], target = 5
Output: 2


Input: nums = [1,3,5,6], target = 2
Output: 1


Input: nums = [1,3,5,6], target = 7
Output: 4
```

---

可以假想把`target`插入到`nums`数组中，再转化为数组长度+1后的标准二分查找。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // num's length +1, therefore right should be 'nums.length' instead of 'nums.length - 1'
        int left = 0, right = nums.length;

        // standard binary search
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        // both left and right are valid
        return left; 
    }
}
```

## 36. Valid Sudoku

Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.

Note:

- A Sudoku board (partially filled) could be valid but is not necessarily solvable.
- Only the filled cells need to be validated according to the mentioned rules.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true


Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```

---

每一个数字只能在所处的行、列、3*3方格内出现一次。因此，构造三个二维数组检查当前数字num分别在当前行、列、方格内出现的次数，超过1次就是不合法的。

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] row = new int[9][9]; // row[i][num] indicates the count of 'num' in the i-th row
        int[][] col = new int[9][9]; // col[j][num] indicates the count of 'num' in the j-th column
        int[][] block = new int[9][9]; // block[k][num] indicates the count of 'num' in the k-th 3*3 block

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                // only validate filled cells
                if (board[i][j] != '.') {
                    int num = board[i][j] - '1';
                    int blockIndex = (i/3) * 3 + j/3;

                    // each num should not duplicate in each row, col, block
                    if (row[i][num] > 0 || col[j][num] > 0 || block[blockIndex][num] > 0) {
                        return false;
                    }
                    
                    row[i][num] += 1;
                    col[j][num] += 1;
                    block[blockIndex][num] += 1;
                }
            }
        }
        return true;
    }
}
```

## 37. Sudoku Solver

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.

The `'.'` character indicates empty cells.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]

Explanation: The input board is shown above and the only valid solution is shown below:
```

![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)

---

遇到一个空方格，从0-9循环填入每一个数字，填完后确认没有违规，再以深度优先，尝试后续所有方格都满足要求，才能保证当前方格也满足要求。

遇到列尾时跳下一行，遇到行尾则说明深度优先搜索结束，数独解决完毕；而如果遇到不符合的情况，则要回溯复原当前填入的数字，再继续循环填入下一个数字。

```java
class Solution {
    public void solveSudoku(char[][] board) {
        solve(board, 0, 0);
    }
    
    // solve based on index
    private Boolean solve(char[][] board, int i, int j) {
        // finish all 9 row
        if (i == 9) {
            return true;
        }
        
        // finish current row, jump to next row
        if (j == 9) {
            return solve(board, i+1, 0);
        }
        
        // non-digit, switch to next column
        if (board[i][j] != '.') {
            return solve(board, i, j+1);
        }

        // backtrack
        for (char c = '1'; c <= '9'; c++) {
            if (check(board, i, j, c)) {
                board[i][j] = c;
                
                // all subsequent cells are valid
                if (solve(board, i, j+1)) {
                    return true;
                }
                
                board[i][j] = '.';
            }
        }
        
        return false; // no solution
    }

    // check if current character is valid
    private Boolean check(char[][] board, int i, int j, char val) {
        for (int c = 0; c < 9; c++) {
            
            // duplicate in current row, column or 3 * 3 block
            if (board[i][c] == val ||
                board[c][j] == val ||
                board[i - i%3 + c/3][j - j%3 + c%3] == val) {
                return false;
            }
        }
        return true;
    }
}
```

## 38. Count and Say

The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

- `countAndSay(1) = "1"`
- `countAndSay(n)` is the way you would "say" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.

To determine how you "say" a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.

For example, the saying and conversion for digit string "3322251":

![](https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg)

Given a positive integer `n`, return the `n`<sup>th</sup> term of the count-and-say sequence.

```
Input: n = 1
Output: "1"
Explanation: This is the base case.


Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = say "1" = one 1 = "11"
countAndSay(3) = say "11" = two 1's = "21"
countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"
```

---

直接的想法是使用递归。递归的起点显然是`n`为1的情况。此后对于任意输入的`n`，先计算出`n-1`的结果字符串`pre`，再遍历`pre`得到`n`的结果。遍历`pre`时，统计当前数字连续出现了几次，把数字和次数直接加到StringBuilder里。

注意使用StringBuilder的目的主要是优化性能，因为String每次追加字符时都会产生新的对象；而StringBuilder与StringBuffer都是直接在同一对象上追加字符，效率很高。另外StringBuffer()适合多线程，而StringBuilder()适合单线程。

```java
class Solution {
    public String countAndSay(int n) {
        if (n == 1) {
            return "1";
        }

        // all upper levels' result
        StringBuilder pre = new StringBuilder(countAndSay(n - 1));
        
        // construct this level
        StringBuilder result = new StringBuilder();

        int i = 0;
        while (i < pre.length()) {
            int count = 0; // current number's count
            int j = i; // start index of current number

            char say = pre.charAt(j);
            while (i < pre.length() && pre.charAt(i) == say) {
                count++;
                i++;
            }

            result.append(count);
            result.append(say);
        }
        return result.toString();
    }
}
```

## 39. Combination Sum

Given an array of distinct integers `candidates` and a `target` integer target, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.

The same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is guaranteed that the number of unique combinations that sum up to `target` is less than 150 combinations for the given input.

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.


Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]


Input: candidates = [2], target = 1
Output: []
```

---

将原始数组排序，并遍历数组，创建一个新的临时数组用于存放当前的组合。每当向临时数组中添加一个数后，更新`target`，递归进入下一层搜索；由于每一个数可以使用无限次，下一次递归的起点下标`index`不变。最后当`target`等于0，说明当前组合满足；否则，则将临时数组中最后一个元素移除，寻找下一个数。


```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(result, new ArrayList<>(), candidates, target, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] candidates, int target, int index) {
        if (target == 0) {
            result.add(new ArrayList<>(temp));
        } else {
            for (int i = index; i < candidates.length && candidates[i] <= target; i++) {
                temp.add(candidates[i]);
                backtrack(result, temp, candidates, target - candidates[i], i); // allow duplicate, thus starts from i
                temp.remove(temp.size() - 1);
            }
        }
    }
}
```

## 40. Combination Sum II

Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.

Each number in `candidates` may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

```
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]


Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
```

---

与上一题几乎一样的题设，唯一不同是输入数组中可能有重复的数字，且数组中每个数只能用一次。只需要稍微改变上一题的代码，调整下一层递归的起始下标；此外，完成一次回溯后，需要及时跳过重复的数字。

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(candidates);
        backtrack(result, new ArrayList<>(), candidates, target, 0);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] candidates, int target, int index) {
        if (target == 0) {
            result.add(new ArrayList<>(temp));
        } else {
            for (int i = index; i < candidates.length && candidates[i] <= target; i++) {
                temp.add(candidates[i]);
                backtrack(result, temp, candidates, target - candidates[i], i + 1); // not allow duplicate, thus starts from i + 1
                temp.remove(temp.size() - 1);
                
                // skip duplicates
                while (i + 1 < candidates.length && candidates[i] == candidates[i + 1]) {
                    i++;
                }
            }
        }
    }
}
```

## 41. First Missing Positive

Given an unsorted integer array `nums`, return the smallest missing positive integer.

You must implement an algorithm that runs in `O(n)` time and uses constant extra space.

```
Input: nums = [1,2,0]
Output: 3


Input: nums = [3,4,-1,1]
Output: 2


Input: nums = [7,8,9,11,12]
Output: 1
```

---

要寻找最小的缺失正整数，可以对数组进行处理：假如遍历发现了1，则将1放在数组第一个位置；发现2，则将2放在数组第二个位置...以此类推。当然，前提是只有遍历的元素值位于0和数组长度之间，才做此处理。

为了达到这一目的，只需要将`nums[i]`与`nums[nums[i] - 1]`进行交换即可。最后，重新遍历顺序处理后的数组，第一个元素值和下标不匹配的元素即为答案。

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            // if nums[i] is in the range of (0, len] and not in its place,
            // put nums[i] on the (nums[i] - 1)th index of the array
            while (nums[i] > 0 && nums[i] <= len && nums[i] != nums[nums[i] - 1]) {
                // swap nums[i] and nums[nums[i] - 1]
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        // the first number unmatched is the answer
        for (int i = 0; i < len; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        // all matched, the smallest positive integer is last integer + 1
        return len + 1;
    }
}
```

## 42. Trapping Rain Water

Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

```
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.


Input: height = [4,2,0,3,2,5]
Output: 9
```

---

使用左右两个指针跟踪当前的池壁高度。根据木桶效应，高度下界`lowerBound`取决于池壁高度较低的一边，而当前已有的水槽高度`currentLevel`则根据较低的池壁高度不断更新。指针移动过程中，新增的水量为`currentLevel`与`lowerBound`的差值。

```java
class Solution {
    public int trap(int[] height) {
        if (height == null || height.length <= 1) {
            return 0;
        }

        int left = 0, right = height.length - 1;
        int currentLevel = 0, result = 0;

        while (left < right) {
            int lowerBound = 0;
            
            // smaller of height[left] and height[right], then move left or right accordingly
            if (height[left] <= height[right]) {
                lowerBound = height[left];
                left++;
            } else {
                lowerBound = height[right];
                right--;
            }   
            
            // update current bar's level
            currentLevel = Math.max(currentLevel, lowerBound);
            
            // new water fills in
            result += currentLevel - lowerBound;
        }
        
        return result;
    }
}
```

## 43. Multiply Strings

Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.

```
Input: num1 = "2", num2 = "3"
Output: "6"


Input: num1 = "123", num2 = "456"
Output: "56088"
```

---

此题限定了输入字符串只包含数字，并且不能直接转成整数再调用乘法计算，实际上便是指定了思路：模拟实现大数的乘法运算，类似于小学进行竖式乘法的过程。

对于一个`m`位整数与一个`n`位整数，其结果的长度一定为`m+n-1`或`m+n`，因此可以提前创建一个长为`m+n`的数组用于存放最终结果的每一位数。双重循环遍历两个整数，可以发现`num1[i] * num2[j]`的结果对应的是`result[i+j+1]`。明确了位数之后，剩余的工作较为简单，只需逐位求值，保留尾数，提取进位向前累加即可。输出结果时，需要去掉起始的0。


```java
class Solution {
    public String multiply(String num1, String num2) {
        int m = num1.length(), n = num2.length();
        
        if (m == 0 || n == 0) {
            return "0";
        }
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }

        // num1[i] * num2[j] reflects on result[i+j+1]
        int[] result = new int[m+n];
        for (int i = m-1; i >= 0; i--) {
            for (int j = n-1; j >= 0; j--) {
                result[i+j+1] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
            }
        }

        // calculate each digit and each carry
        int carry = 0;
        for (int k = result.length - 1; k >= 0; k--) {
            int digit = (result[k] + carry) % 10;
            carry = (result[k] + carry) / 10;
            result[k] = digit;
        }

        StringBuilder sb = new StringBuilder();
        
        // trim all leading 0
        for (int each : result) {
            if (!(each == 0 && sb.length() == 0)) {
                sb.append(each);
            }
        }
            
        return sb.toString();
    }
}
```

## 44. Wildcard Matching

Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:

- `'?'` Matches any single character.
- `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".


Input: s = "aa", p = "*"
Output: true
Explanation: '*' matches any sequence.


Input: s = "cb", p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
```

---

解法一，参考Regular Expression Matching中的解法，使用二维动态规划：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length()+1];
        dp[0][0] = true;

        // empty pattern cannot match with any string
        for (int i = 1; i <= s.length(); i++) {
            dp[i][0] = false;
        }

        // multiple '*' pattern can match with empty string
        for (int j = 1; j <= p.length(); j++) {
            if (p.charAt(j-1) != '*') {
                break;
            } else {
                dp[0][j] = true;
            }
        }

        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < p.length(); j++) {
                if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?') {
                    dp[i+1][j+1] = dp[i][j];
                } else if (p.charAt(j) == '*') {
                    dp[i+1][j+1] = dp[i+1][j] || dp[i][j+1];
                } else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[s.length()][p.length()];
    }
}
```

解法二，使用指针：

使用两个指针`sIdx`和`pIdx`分别跟踪`s`和`p`，分类讨论所有情况：

- 严格的单字对应，或`p`中出现`?`，两个指针分别前移
- `p`遇到`*`，暂不清楚匹配情况，记录`s`当前的匹配起点和`p`最近一个`*`的位置，前移`pIdx`
- 前一个`pIdx`是`*`，但现在不是，可能对应着匹配多个字符的情况，将`pIdx`置于最近一个*的右侧，并前移`sIdx`


其他情况下，直接判定为匹配失败。

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int sIdx = 0, pIdx = 0, match = 0, starIdx = -1;            
        
        while (sIdx < s.length()) {
            if (pIdx < p.length() && (p.charAt(pIdx) == '?' || s.charAt(sIdx) == p.charAt(pIdx))) {
                // regular match or match ?, moving both pointers forward
                sIdx++;
                pIdx++;
            } else if (pIdx < p.length() && p.charAt(pIdx) == '*') {
                // * found, only moving pattern pointer forward
                starIdx = pIdx; // update the latest *'s index
                match = sIdx;
                pIdx++;
            } else if (starIdx != -1) {
                // last pattern pointer was * but current is not, moving string pointer forward to match
                pIdx = starIdx + 1;
                sIdx = ++match;
            } else return false;
        }

        // check for remaining characters in pattern
        while (pIdx < p.length() && p.charAt(pIdx) == '*') {
            pIdx++;
        }
        
        return pIdx == p.length();
    }
}
```

## 45. Jump Game II

Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.


Input: nums = [2,3,0,1,4]
Output: 2
```

---

此题需要使用贪心算法。第`i`次跳跃中，必然有`nums[i]`个可选落点，检查每一个可选落点最远可以到达何处，选取最远的一个作为下一次跳跃的最远边界。以此类推，每一步都选择下一步可能最远的落点，直到最终可以到达终点。

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int steps = 0; // steps taken 
        int start = 0, end = 0; // in current step, I can reach the interval [start, end]
        int maxEnd = 0; // the farthest fall of the jump
        
        while (end < nums.length - 1) {
            steps++;

            // find out the maxEnd
            for (int i = start; i <= end; i++) {
                maxEnd = Math.max(maxEnd, nums[i] + i);
            }
                
            // generate next [start, end] range
            start = end + 1; // next range's start must be larger than current range's end
            end = maxEnd;
        }
        
        return steps;
    }
}
```

## 46. Permutations

Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]


Input: nums = [0,1]
Output: [[0,1],[1,0]]


Input: nums = [1]
Output: [[1]]
```

---

使用通用的回溯算法解题模版。使用一个boolean数组跟踪每个下标的数字是否使用过，add前标记为使用，remove前标记为未使用。

```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        backtrack(result, nums, new ArrayList<>(), new boolean[nums.length]);
        return result;
    }

    private void backtrack(List<List<Integer>> result, int[] nums, List<Integer> temp, boolean[] used) {
        // match with num's length, add this permutation to result
        if (temp.size() == nums.length) {
            result.add(new ArrayList<>(temp));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            // current number has already been used, skip
            if (used[i] == true) {
                continue;
            }

            // set current number as used and add it to temp permutation
            used[i] = true;
            temp.add(nums[i]);

            backtrack(result, nums, temp, used);

            // after using, reset current number as unused and remove it from temp permutation
            used[i] = false;
            temp.remove(temp.size() - 1);
        }
    }
}
```

## 47. Permutations II

Given a collection of numbers, `nums`, that might contain duplicates, return all possible unique permutations in any order.

```
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]


Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

---

此题的输入数组可能含有重复的数字，只需要在上一题的基础上，跳过重复的数字即可。

需要注意，判断重复时，`used[i - 1]`和`!used[i - 1]`都能让代码成功运行，然而LeetCode运行时间显示，`!used[i - 1]`快的多，可能是因为LeetCode生成的随机测试数据中，包含重复的情况较多，因此我们发现当前一个相同的数字被使用时，我们也优先加入当前这个相同的数字，这样能更快试出所有permutation。

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        backtrack(result, nums, new ArrayList<>(), new boolean[nums.length]);
        return result;
    }

    private void backtrack(List<List<Integer>> result, int[] nums, List<Integer> temp, boolean[] used) {
        // match with num's length, add this permutation to result
        if (temp.size() == nums.length) {
            result.add( new ArrayList<>(temp) );
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            // current number is used / if previous identical number is used, use current number
            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) continue;

            // mark current number as used and add it to temp permutation
            used[i] = true;
            temp.add(nums[i]);

            backtrack(result, nums, temp, used);

            // after using, unmark current number as unused and remove it from temp permutation
            used[i] = false;
            temp.remove(temp.size() - 1);
        }
    }
}
```

## 48. Rotate Image

You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

---

观察发现，矩阵内的元素旋转实际上是在建构一个旋转矩形，矩形顶点的轮换导致了整个矩阵的变化。

例如对于例子中的两个矩阵，第一个矩阵中2, 4, 6, 8构成了一个旋转矩形，第二个矩阵中1, 10, 12, 13构成了一个旋转矩形。因此，对于任意一个`matrix[i][j]`，总能找到另外三个矩阵坐标顶点与之构成一个旋转矩形，只需推出其数学表达式即可。

```java
class Solution {
    public void rotate(int[][] matrix) {
        if (matrix == null) {
            return;
        }
        int len = matrix.length;

        // locate four corner points
        for (int i = 0; i < (len + 1) / 2; i++) {
            for (int j = 0; j < matrix[0].length / 2; j++) {
                int temp = matrix[i][j]; // first
                matrix[i][j] = matrix[len - 1 - j][i]; // second
                matrix[len - 1 - j][i] = matrix[len - 1 - i][len - 1 - j]; // third
                matrix[len - 1 - i][len - 1 - j] = matrix[j][len - 1 - i]; // fourth
                matrix[j][len - 1 - i] = temp;
            }
        }  
    }
}
```

## 49. Group Anagrams

Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

```
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]


Input: strs = [""]
Output: [[""]]


Input: strs = ["a"]
Output: [["a"]]
```

---

统计每个单词中各个字母出现的次数，存到一个长度为26的数组中。利用这个数组生成对应的hash码(`Arrays.hashCode()`)，具有相同hash码的字符串就可以被归类在一起。

如果字符串很短的情况下，也可以每一个字母映射一个质数，质数相乘作为hashcode，提升运行效率。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> result = new ArrayList<>(); 
        
        // <hash number, list index in result>
        Map<Integer, Integer> map = new HashMap<>();
        
        for (String s: strs) {
            int key = getKey(s);
            int resultIndex = map.getOrDefault(key, -1);
            
            List<String> list = null;
            if (resultIndex == -1) {
                list = new ArrayList<>();
                result.add(list);
                map.put(key, result.size() - 1);
            } else {
                list = result.get(resultIndex);
            }
            
            list.add(s);
        }
        return result;
    }
    
    // use count to generate hash number
    public int getKey(String s) {
        int[] map = new int[26];
        for (char c: s.toCharArray()) {
            map[c - 'a']++;
        }
        return Arrays.hashCode(map);
    }
}
```

## 50. Pow(x, n)

Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., `x`<sup>n</sup>).

```
Input: x = 2.00000, n = 10
Output: 1024.00000


Input: x = 2.10000, n = 3
Output: 9.26100


Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

---

实现幂函数的构造需要运用递归。然而在开始递归前，需要先排除一些输入的特殊情况。`n`和`x`各有若干特殊情况：

- 输入的`x`为1，或是`n`为0，或是`x`为-1且`n`为整数下界，返回1
- 输入的`x`为0，或是`x`不为-1且`n`为整数下界，返回0
- 输入的`n`为负数，利用`x`<sup>n</sup> = `(1/x)`<sup>-n</sup>这一特点，将`n`转化成正数。

完成上述处理后，分`n`的奇偶性进行递归调用。对于奇数，由于整数除法的舍入，需要额外乘一个`x`。

```java
public double myPow(double x, int n) {
    if (x == 1 || n == 0 || (n == Integer.MIN_VALUE && x == -1)) {
        return 1;
    }
    if (x == 0 || (n == Integer.MIN_VALUE && x != -1)) {
        return 0;
    }
    if (n < 0) {
        n = -n;
        x = 1/x;
    }
    // odd or even
    return (n % 2 == 0) ? myPow(x * x, n / 2) : x * myPow(x * x, n / 2);
}
```