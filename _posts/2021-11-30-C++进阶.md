---
title: C++进阶
tags: Notes Computer-Science C++
article_header:
  type: 
  image:
    src: 
---

C++11开始的新特性与改变，以及补充一些容易混淆、概念抽象的C++知识

<!--more-->

# C++1x新特性

## 弃用特性


弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分特性其实会永久保留。


- 不再允许字符串字面值常量赋值给一个 char _。如果需要用字符串字面值常量赋值和初始化一个 char _，应该使用 const char * 或者 auto
```cpp
char *str = "hello world!"; // 将出现弃用警告
```

- C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用，应该使用 noexcept
- auto_ptr 被弃用，应使用 unique_ptr
- register 关键字被弃用，可以使用但不再具备任何实际含义
- bool 类型的 ++ 操作被弃用
- 如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用
- C 语言风格的类型转换被弃用（即在变量前使用 (convert_type)），应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换
- 特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 、、 与 



## 与C的兼容性


出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码（甚至古老的 C 语言代码），例如 Linux 系统调用。下图是C和C++相关的兼容情况：

![c-c++.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/C++/c-c++.png)

在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。而在不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，例如：


```cpp
// foo.h
#ifdef __cplusplus
extern "C" {
#endif

int add(int x, int y);

#ifdef __cplusplus
}
#endif

// foo.c
int add(int x, int y) {
    return x+y;
}

// foo.cpp
#include "foo.h"
#include <iostream>
#include <functional>

int main() {
    [out = std::ref(std::cout << "Result from C code: " << add(1, 2))](){
        out.get() << ".\n";
    }();
    return 0;
}
```


## 语言可用性的强化


### 常量


1. nullptr
    
    nullptr 出现的目的是为了替代 NULL。在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义为 0。
    C++ 不允许直接将 void _ 隐式转换到其他类型。如果编译器尝试把 NULL 定义为 ((void_)0)，缺少void * 隐式转换的 C++ 只好将 NULL 定义为 0。这样一来，可能导致函数重载发生混乱：

    ```cpp
    char *ch = NULL; // NULL 定义为 0

    // 两个函数重载
    void foo(char*);
    void foo(int);  

    foo(NULL); //此时将调用foo(int)，而非直觉上的foo(char*)
    ```

    为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较：

    ```cpp
    #include <iostream>
    #include <type_traits>

    void foo(char *);
    void foo(int);

    int main() {
        if (std::is_same<decltype(NULL), decltype(0)>::value)
            std::cout << "NULL == 0" << std::endl;
        if (std::is_same<decltype(NULL), decltype((void*)0)>::value)
            std::cout << "NULL == (void *)0" << std::endl;
        if (std::is_same<decltype(NULL), std::nullptr_t>::value)
            std::cout << "NULL == nullptr" << std::endl;

        foo(0);          // 调用 foo(int)
        // foo(NULL);    // 该行不能通过编译
        foo(nullptr);    // 调用 foo(char*)
        return 0;
    }

    void foo(char *) {
        std::cout << "foo(char*) is called" << std::endl;
    }
    void foo(int i) {
        std::cout << "foo(int) is called" << std::endl;
    }
    ```

2. constexpr(常量表达式)

    C++ 本身已经具备了常量表达式的概念，比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式。
    使用常量表达式的要求很严格，需要满足以下条件：
    - 函数必须返回值，不能是`void`
    - 函数在使用前必须定义
    - return语句中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式

    ```cpp
    #include <iostream>
    #define LEN 10

    int len_foo() {
        int i = 2;
        return i;
    }
    constexpr int len_foo_constexpr() {
        return 5;
    }

    constexpr int fibonacci(const int n) {
        return n == 1 || n == 2 ? 1 : fibonacci(n-1) + fibonacci(n-2);
    }

    int main() {
        char arr_1[10];                      // 合法
        char arr_2[LEN];                     // 合法

        int len = 10;
        // char arr_3[len];                  // 非法

        const int len_2 = len + 1;
        constexpr int len_2_constexpr = 1 + 2 + 3;
        // char arr_4[len_2];                // 非法
        char arr_4[len_2_constexpr];         // 合法

        // char arr_5[len_foo()+5];          // 非法
        char arr_6[len_foo_constexpr() + 1]; // 合法

        std::cout << fibonacci(10) << std::endl;
        // 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
        std::cout << fibonacci(10) << std::endl;
        return 0;
    }
    ```

    注意C++1x中，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句，并且也可以使用递归。上文中的fibonacci()就是这样的例子。
    此外，有时候需要用到“编译时常量”时，const的约束是不够的。例如以下例子：
    ```cpp
    // 仅保证运行时的常量性
    const int getConst() {
        return 1;
    }

    int main() {
        // 无法通过编译，因为数组的长度需要在编译时就确定
        int arr[getConst()] = {0};
    }
    ```


    `constexpr`在此处若替换`const`，即可达到想要的效果。


### 变量与初始化


1. if/switch变量声明强化

    在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch 语句中声明一个临时的变量。C++17 消除了这一限制，使得我们可以在 if（或 switch）中完成这一操作：
    
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>

    int main() {
        std::vector<int> vec = {1, 2, 3, 4};

        // 在 c++17 之前
        const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 2);
        if (itr != vec.end()) {
            *itr = 3;
        }

        // 需要重新定义一个新的变量
        const std::vector<int>::iterator itr2 = std::find(vec.begin(), vec.end(), 3);
        if (itr2 != vec.end()) {
            *itr2 = 4;
        }

        // 将输出 1, 4, 3, 4
        for (std::vector<int>::iterator element = vec.begin(); element != vec.end(); ++element)
            std::cout << *element << std::endl;
    }

    // c++ 17之后
    // 将临时变量放到 if 语句内
    if (const std::vector<int>::iterator itr = std::find(vec.begin(), vec.end(), 3);
        itr != vec.end()) {
        *itr = 4;
    }
    ```

2. 初始化列表(initializer list)

    对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 () 进行。 这些不同方法都针对各自对象，不能通用。为了解决这个问题，C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：

    ```cpp
    #include <initializer_list>
    #include <vector>

    class MagicFoo {
    public:
        std::vector<int> vec;
        MagicFoo(std::initializer_list<int> list) {
            for (std::initializer_list<int>::iterator it = list.begin();
                it != list.end(); ++it)
                vec.push_back(*it);
        }
    };
    int main() {
        // after C++11
        MagicFoo magicFoo = {1, 2, 3, 4, 5};

        std::cout << "magicFoo: ";
        for (std::vector<int>::iterator it = magicFoo.vec.begin(); it != magicFoo.vec.end(); ++it) std::cout << *it << std::endl;
    }
    ```

    初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：
    ```cpp
    public:
        void foo(std::initializer_list<int> list) {
                for (std::initializer_list<int>::iterator it = list.begin(); it != list.end(); ++it) vec.push_back(*it);
        }

    magicFoo.foo({6,7,8,9});
    ```

3. 结构化绑定(structured bindings)

    结构化绑定提供了类似其他语言中提供的多返回值的功能。C11 新增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素。C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：

    ```cpp
    #include <iostream>
    #include <tuple>

    std::tuple<int, double, std::string> f() {
        return std::make_tuple(1, 2.3, "456");
    }

    int main() {
        auto [x, y, z] = f();
        std::cout << x << ", " << y << ", " << z << std::endl;
        return 0;
    }
    ```

4. 花括号初始化拓展

    C++11开始，拓展了可以使用花括号的列表对变量进行初始化的范围：
    ```cpp
    int a[] = { 1, 3, 5}; // C++98编译通过，C++11编译通过
    int b[] { 1, 3, 5}; // C++98编译失败，C++11编译通过
    vector<int> c{1, 3, 5}; // C++98编译失败，C++11编译通过
    map<int, float> d = { { 1, 1.0f }, { 3, 3.0f }, { 5, 5.0f } }; // C++98失败，C++11通过

    struct s {
        int x;
        string str;
        vector<int> vec;
    };

    s s1{1, "abcde", {2, 4, 6, 8, 10}};
    ```

5. 在初始化的时候，加强了对类型收窄问题的限制，编译器不允许部分出现使得数据变化或者精度丢失的隐式类型转换。以下例子都是类型收窄，部分不能通过编译：

    ```cpp
    // 通过编译
    char a = x;
    char* b = new char(1024);

    // 不能通过编译
    char c = {x};
    unsigned char d {-1};
    float* e = new float { 1e48 }; // 1e48过大
    ```


### 类型推导

C++11中，`auto`关键词被赋予了新的作用，它可以自动推导变量的类型。


`auto`的一个明显的用处就是简化代码，例如我们需要遍历STL容器时，对比两种写法：


```cpp
map<string, string> sample_map;
for (map<string, string>::iterator iter = sample_map.begin(); iter != sample_map.end(); iter++) {
    // ...
}


for (auto iter = sample_map.begin(); iter != sample_map.end(); iter++) {
    // ...
}
```


`decltype`是另一个使用类型推导的关键字，基本语法为 `decltype(value_name) val`：


```cpp
int a;
string b;
struct {
    int x, y;
} temp_position;

decltype(a) i; // int
decltype(b) s; // string
decltype(temp_position) pos; // 复用匿名struct
```


需要注意，`auto`和`decltype`都是编译时推导变量的类型，而不能在运行时推导变量类型。而且，推导有一定的限制：


```cpp
auto i; // compile error
int foo(auto a, auto b); // valid in C++ 14
int bar(auto a = 1, auto b = 1); // compile error
```


此外，类型推导还可以用于追踪返回类型(Return Value Tracking)。追踪返回类型的函数和普通函数的声明最大区别在于返回类型的后置：


```cpp
int func(char* a, int b);
auto func(char* a, int b) -> int;
```


追踪返回类型还可以让我们在写返回类型时，不写明作用域。比较以下两个函数的写法，这两个函数作用完全一致，都是一个返回函数指针的函数，而这个指针指向着返回`int*`的函数。引入类型推导后，函数的可读性大不相同：


```cpp
int (*(*pf()) ()) () { return nullptr; }

auto pf1() -> auto (*)() -> int (*)() { return nullptr; }
```


另一个例子：


```cpp
template<typename T, typename U>
auto add3(T x, U y){
    return x + y;
}

std::cout << "q: " << q << std::endl;
```


decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 decltype 的参数表达式。考虑以下例子：


```cpp
std::string  lookup1();
std::string& lookup2();

// c++11
std::string look_up_a_string_1() {
    return lookup1();
}
std::string& look_up_a_string_2() {
    return lookup2();
}

// c++14开始
decltype(auto) look_up_a_string_1() {
    return lookup1();
}
decltype(auto) look_up_a_string_2() {
    return lookup2();
}
```


### 仿函数(Functor）


仿函数又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 `operator()` 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 `operator()` 运算符。


比起lambda函数而言，仿函数的语法限制更小。


```cpp
class func1 { 
    public :
    func1 & operator () ( int x ) {
        std :: cout << x << std :: endl; 
        return * this;
    }
} f1;

f1 ( 11 ) ( 12 ) ( 13 ) ;
```


### 控制流


1. if constexpr

    在引入了 constexpr 关键字之后，一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17实现了这一想法，将 constexpr 这个关键字引入到 if 语句中，允许在代码中声明常量表达式的判断条件：

    ```cpp
    #include <iostream>

    template<typename T>
    auto print_type_info(const T& t) {
        if constexpr (std::is_integral<T>::value) {
            return t + 1;
        } else {
            return t + 0.001;
        }
    }
    int main() {
        std::cout << print_type_info(5) << std::endl;
        std::cout << print_type_info(3.14) << std::endl;
    }
    ```

    编译后，代码实际表现如下：

    ```cpp
    int print_type_info(const int& t) {
        return t + 1;
    }
    double print_type_info(const double& t) {
        return t + 0.001;
    }
    int main() {
        std::cout << print_type_info(5) << std::endl;
        std::cout << print_type_info(3.14) << std::endl;
    }
    ```

2. 区间for迭代

    C++11 引入了基于范围的迭代写法，与Python等高级语言类似：

    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>

    int main() {
        std::vector<int> vec = {1, 2, 3, 4};
        if (auto itr = std::find(vec.begin(), vec.end(), 3); itr != vec.end()) *itr = 4;

        for (auto element : vec)
            std::cout << element << std::endl; // read only

        for (auto &element : vec) {
            element += 1;                      // writeable
        }
    }
    ```


### 模版


1. 外部模版

    传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。
    为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：

    ```cpp
    template class std::vector<bool>;          // 强行实例化
    extern template class std::vector<double>; // 不在该当前编译文件中实例化模板
    ```

2. 尖括号

    在传统 C++ 的编译器中，>>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码，例如`std::vector<std::vector<int>> matrix;`，这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。

3. 类型别名模版

    在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称，因为模板不是类型。C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效：

    ```cpp
    template<typename T, typename U>
    class MagicType {
    public:
        T dark;
        U magic;
    };

    typedef int (*process)(void *);
    using NewProcess = int(*)(void *);
    template<typename T>
    using TrueDarkMagic = MagicType<std::vector<T>, std::string>;

    int main() {
        TrueDarkMagic<bool> you;
    }
    ```

4. 默认模版参数

    C++11 中提供了一种便利，可以指定模板的默认参数：

    ```cpp
    template<typename T = int, typename U = int>
    auto add(T x, U y) -> decltype(x+y) {
        return x+y;
    }

    auto ret = add<int, int>(1,3); // 常规调用方式

    auto ret = add(1,3); // 带默认参数调用方式
    ```

5. 变长参数模版

    在 C11 之前，无论是类模板还是函数模板，都只能按其指定的样子， 接受一组固定数量的模板参数；而 C11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。
    假如对于模版类Magic的对象，能够接受不受限制个数的 typename 作为模板的形式参数：

    ```cpp
    template<typename... Ts> class Magic;

    class Magic<int,
            std::vector<int>,
            std::map<std::string,
            std::vector<int>>> darkMagic;
    ```

    既然是任意形式，所以个数为 0 的模板参数也是可以的：`class Magic<> nothing`。
    如果不希望产生的模板参数个数为 0，可以手动的定义至少一个模板参数：
    ```cpp
    template<typename Require, typename... Args> class Magic;
    ```

    C++17中，变长参数特性被进一步进一步发展，带来了折叠表达式特性：

    ```cpp
    C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：
    #include <iostream>
    template<typename ... T>
    auto sum(T ... t) {
        return (t + ...);
    }
    int main() {
        std::cout << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << std::endl;
    }
    ```

6. 非类型模版参数推导

    有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数。在这种模板参数形式下，我们可以传递一些常数作为模板的参数，甚至在C++17之后，还可以通过使用占位符 auto 从而不再需要明确指明类型：

    ```cpp
    template <typename T, int BufSize>
    class buffer_t {
    public:
        T& alloc();
        void free(T& item);
    private:
        T data[BufSize];
    }

    buffer_t<int, 100> buf; // 100 作为模板参数


    template <auto value> void foo() {
        std::cout << value << std::endl;
        return;
    }

    int main() {
        foo<10>();  // value 被推导为 int 类型
    }
    ```

### 面向对象


1. 委托构造

    在C++98中，如果想让两个构造函数完成相似的事情，可以写两个大段代码相同的构造函数，或者是另外定义一个init()函数，让两个构造函数都调用这个init()函数。这样的实现方式重复罗嗦，并且容易出错。并且，这两种方式的可维护性都很差。
    C++11 引入了委托构造的概念，函数解决了这个问题，它允许我们构造函数时让同一个类中一个构造函数调用另一个构造函数：
    ```cpp
    class X {
        int a;

        public:

            X(int x) {
                if (0 < x && x <= max) a = x;
                else throw bad_X(x);
            }

            // 构造函数X()调用构造函数X(int x)
            X() : X{42} {}

            // 构造函数X(string s)调用构造函数X(int x)
            X(string s) : X{lexical_cast<int>(s)} {}
    };
    ```

2. 继承构造

    在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：

    ```cpp
    #include <iostream>
    class Base {
    public:
        int value1;
        int value2;
        Base() {
            value1 = 1;
        }
        Base(int value) : Base() { // 委托 Base() 构造函数
            value2 = value;
        }
    };
    class Subclass : public Base {
    public:
        using Base::Base; // 继承构造
    };
    int main() {
        Subclass s(3);
        std::cout << s.value1 << std::endl;
        std::cout << s.value2 << std::endl;
    }
    ```

3. 显式虚函数重载

    在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：

    ```cpp
    struct Base {
        virtual void foo();
    };
    struct SubClass: Base {
        void foo();
    };
    ```

    SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。
    C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。

    **override**

    当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：

    ```cpp
    struct Base {
        virtual void foo(int);
    };
    struct SubClass: Base {
        virtual void foo(int) override; // 合法
        virtual void foo(float) override; // 非法, 父类没有此虚函数
    };
    ```

    **final**

    防止类被继续继承以及终止虚函数继续重载。

    ```cpp
    struct Base {
        virtual void foo() final;
    };
    struct SubClass1 final: Base {
    }; // 合法

    struct SubClass2 : SubClass1 {
    }; // 非法, SubClass1 已 final

    struct SubClass3: Base {
        void foo(); // 非法, foo 已 final
    };
    ```

4. 显式禁用默认函数

    传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、 复制构造、赋值算符以及析构函数。这导致无法精确控制默认函数的生成行为。例如，禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 private；编译器产生的默认构造函数与用户定义的构造函数无法同时存在。 若用户定义了任何构造函数，编译器将不再生成默认构造函数，但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。
    C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。例如：

    ```cpp
    class Magic {
        public:
        Magic() = default; // 显式声明使用编译器生成的构造
        Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造
        Magic(int magic_number);
    }
    ```

5. 强类型枚举

    在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较，甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同，这通常不是我们希望看到的结果。
    C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：

    ```cpp
    enum class new_enum : unsigned int {
        value1,
        value2,
        value3 = 100,
        value4 = 100
    };
    ```

    这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较， 更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较。而我们希望获得枚举值的值时，将必须显式的进行类型转换，可以通过重载 << 这个算符来进行输出：

    ```cpp
    if (new_enum::value3 == new_enum::value4) {
        // 会输出
        std::cout << "new_enum::value3 == new_enum::value4" << std::endl;
    }


    template<typename T>
    std::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)
    {
        return stream << static_cast<typename std::underlying_type<T>::type>(e);
    }
    ```


### 普通老式数据(Plain Old Data, POD)


Plain意为POD是普通的类型，而不像一些存在着虚函数虚继承的类型那么特别。它有3个好处：


- 体现了其与C的兼容性，比如可以使用`memcpy()`进行复制，使用`memset()`进行初始化
- 提供对C内存布局兼容。POD类型的数据在C和C++间的操作总是安全的
- 保证静态初始化的安全有效。静态初始化能在很多时候提高程序性能，而POD类型对象初始化往往更加简单



想知道某个类型是否是POD时，可以使用标准库中的`template <typename T> struct std::is_pod`方法判断。注意，从C++20开始，这个方法也不被提倡使用，官方建议使用其他替代函数，例如is_trivial判断TrivialType(一个标量类型，具有普通默认构造函数的可复制类，或这类类型/类的数组)。


## 语言运行期的强化


### Lambda表达式（匿名函数）


基本语法：

```cpp
[capture](parameters) mutable -> return_type { statement }
```
- `[capture]`：捕获列表
- `(parameters)`: 参数列表
- `mutable`: 默认情况下，lambda函数总是一个const函数，mutable可以取消其常量性
- `return_type`: 返回类型
- `statement`: 函数体。可以使用捕获的变量



所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：


**值捕获**


与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，而非调用时才拷贝：


```cpp
void lambda_value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout << "stored_value = " << stored_value << std::endl;
    // 这时, stored_value == 1, 而 value == 100.
    // 因为 copy_value 在创建时就保存了一份 value 的拷贝
}
```


**引用捕获**


与引用传参类似，引用捕获保存的是引用，值会发生变化。


```cpp
void lambda_reference_capture() {
    int value = 1;
    auto copy_value = [&value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout << "stored_value = " << stored_value << std::endl;
    // 这时, stored_value == 100, value == 100.
    // 因为 copy_value 保存的是引用
}
```


**表达式捕获**


上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。


C++14给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获， 被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：


```cpp
#include <iostream>
#include <utility>

int main() {
    auto important = std::make_unique<int>(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
        return x+y+v1+(*v2);
    };
    std::cout << add(3,4) << std::endl;
    return 0;
}
```


结合例子应用：


```cpp
// 排序
std::array <int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};

std::sort(s.begin(), s.end(), [](int a, int b){
    return a < b;
});
```


```cpp
fromto = [ ] ( auto start, auto finish ) { 
    return [ = ] ( ) mutable {
        if ( start < finish ) return start++;
        else throw std :: runtime_error ( "Complete" ) ;
    }; 
};

auto range = fromto ( 0 , 10 ) ;
std :: cout << range ( ) << std :: endl ; // 0
std :: cout << range ( ) << std :: endl ; // 1
std :: cout << range ( ) << std :: endl ; // 2
std :: cout << range ( ) << std :: endl ; // 3
```


另外，从 C++14 开始， Lambda 函数的形式参数可以使用 auto 关键字来产生意义上的泛型：


```cpp
auto add = [](auto x, auto y) {
    return x+y;
};

add(1, 2);
add(1.1, 2.2);
```


### 函数对象包装器


1. std::function

    C11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如：

    ```cpp
    #include <functional>
    #include <iostream>

    int foo(int para) {
        return para;
    }

    int main() {
        // std::function 包装了一个返回值为 int, 参数为 int 的函数
        std::function<int(int)> func = foo;

        int important = 10;
        std::function<int(int)> func2 = [&](int value) -> int {
            return 1+value+important;
        };
        std::cout << func(10) << std::endl;
        std::cout << func2(10) << std::endl;
    }
    ```

2. std::bind和std::placeholder

    std::bind是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。例如：

    ```cpp
    int foo(int a, int b, int c) {
        ;
    }
    int main() {
        // 将参数1,2绑定到函数 foo 上，但是使用 std::placeholders::_1 来对第一个参数进行占位
        auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2);
        // 这时调用 bindFoo 时，只需要提供第一个参数即可
        bindFoo(1);
    }
    ```


### 右值引用


1. 左值和右值

    要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解：

    **左值(lvalue, left value)**，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
    **右值(rvalue, right value)**，右边的值，是指表达式结束后就不再存在的临时对象。C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分：
    - **纯右值(prvalue, pure rvalue)**，纯粹的右值，要么是纯粹的字面量，例如 10, true；要么是求值结果相当于字面量或匿名临时对象，例如 1+2。各种非引用返回、运算产生的临时变量、原始字面量、Lambda 表达式都属于纯右值
    - **将亡值(xvalue, expiring value)**，是 C11 为了引入右值引用而提出的概念（因此在传统 C 中，纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。看以下例子：

    ```cpp
    std::vector<int> foo() {
        std::vector<int> temp = {1, 2, 3, 4};
        return temp;
    }

    // v 是左值、 foo() 返回的值就是右值（也是纯右值）。但是，v 可以被别的变量捕获到， 而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。
    std::vector<int> v = foo();
    ```

    要拿到一个将亡值，就需要用到右值引用：T &&，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。

    ```cpp
    int foo() {
        return 1;
    }

    int main() {
        int && a = foo(); // foo()的返回值不会被立即销毁
        return 0;
    }
    ```
    ```cpp
    #include <iostream>
    #include <string>

    void reference(std::string& str) {
        std::cout << "左值" << std::endl;
    }
    void reference(std::string&& str) {
        std::cout << "右值" << std::endl;
    }

    int main()
    {
        std::string lv1 = "string,"; // lv1 是一个左值
        // std::string&& r1 = lv1; // 非法, 右值引用不能引用左值
        std::string&& rv1 = std::move(lv1); // 合法, std::move可以将左值转移为右值
        std::cout << rv1 << std::endl; // string,

        const std::string& lv2 = lv1 + lv1; // 合法, 常量左值引用能够延长临时变量的生命周期
        // lv2 += "Test"; // 非法, 常量引用无法被修改
        std::cout << lv2 << std::endl; // string,string

        std::string&& rv2 = lv1 + lv2; // 合法, 右值引用延长临时对象生命周期
        rv2 += "Test"; // 合法, 非常量引用能够修改临时变量
        std::cout << rv2 << std::endl; // string,string,string,Test

        reference(rv2); // 输出左值

        return 0;
    }
    ```

2. 移动语义

    右值引用很适合拷贝构造函数需要深拷贝的场合，可以实现移动语义。所谓移动语义，就是从将要销毁的临时变量那里把资源移动过来。这样就节省了分配空间和复制值的开销。

    ```cpp
    MyPool(MyPool && oth) {
        pool = oth.pool;
        oth.pool = nullptr;
    }
    ```

    此外，C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：

    ```cpp
    #include <iostream>
    class A {
    public:
        int *pointer;
        A():pointer(new int(1)) { 
            std::cout << "构造" << pointer << std::endl; 
        }
        A(A& a):pointer(new int(*a.pointer)) { 
            std::cout << "拷贝" << pointer << std::endl; 
        } // 无意义的对象拷贝
        A(A&& a):pointer(a.pointer) { 
            a.pointer = nullptr;
            std::cout << "移动" << pointer << std::endl; 
        }
        ~A(){ 
            std::cout << "析构" << pointer << std::endl; 
            delete pointer; 
        }
    };
    // 防止编译器优化
    A return_rvalue(bool test) {
        A a,b;
        if(test) return a; // 等价于 static_cast<A&&>(a);
        else return b;     // 等价于 static_cast<A&&>(b);
    }
    int main() {
        A obj = return_rvalue(false);
        std::cout << "obj:" << std::endl;
        std::cout << obj.pointer << std::endl;
        std::cout << *obj.pointer << std::endl;
        return 0;
    }

    // 首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出

    // 函数返回后，产生一个将亡值，被 A 的移动构造（A(A&&)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。
    ```

    基于移动语义，我们可以实现移动构造函数，并与传统的拷贝构造函数进行对比：
    - 拷贝构造函数创建一个新的对象作为现有对象的副本。然而，这样的复制时间和空间开销很大，因为必须分配内存和进行深拷贝。
    - 移动构造函数是尽可能快地从原始对象中窃取更多的资源，因为原始对象已经不需要有意义的价值了。我们可能只需要修改几个指针就可以达到目的。

3. 完美转发

    C++引入了右值引用，使得语法上多了一条折叠规则。假设有：

    ```cpp
    typedef int T;
    typedef T& TR;
    ```
    我们能总结出以下表格：

    | TR的类型定义 | 声明变量v的类型 | v的实际类型 |
    | :---: | :---: | :---: |
    | T& | TR | int& |
    | T& | TR& | int& |
    | T& | TR&& | int& |
    | T&& | TR | int&& |
    | T&& | TR& | int& |
    | T&& | TR&& | int&& |

    根据上述的表格，有以下的折叠可能：

    ```cpp
    // T为const int& 或 int&
    void Forward(const int& && t);
    // 折叠成
    void Forward(const int& t);



    // T为int&&
    void Forward(int&& &&t);
    // 折叠成
    void Forward(const int&& t);
    ```

    完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用std::forward来进行参数的转发（传递）：

    ```cpp
    #include <iostream>
    #include <utility>
    void reference(int& v) {
        std::cout << "左值引用" << std::endl;
    }
    void reference(int&& v) {
        std::cout << "右值引用" << std::endl;
    }
    template <typename T>
    void pass(T&& v) {
        std::cout << "              普通传参: ";
        reference(v);
        std::cout << "       std::move 传参: ";
        reference(std::move(v));
        std::cout << "    std::forward 传参: ";
        reference(std::forward<T>(v));
        std::cout << "static_cast<T&&> 传参: ";
        reference(static_cast<T&&>(v));
    }
    int main() {
        std::cout << "传递右值:" << std::endl;
        pass(1);

        std::cout << "传递左值:" << std::endl;
        int v = 1;
        pass(v);

        return 0;
    }


    // 传递右值:
    //               普通传参: 左值引用
    //        std::move 传参: 右值引用
    //     std::forward 传参: 右值引用
    // static_cast<T&&> 传参: 右值引用
    // 传递左值:
    //               普通传参: 左值引用
    //        std::move 传参: 右值引用
    //     std::forward 传参: 左值引用
    // static_cast<T&&> 传参: 左值引用
    ```

    无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发， 所以 std::move 总会接受到一个左值，从而转发调用了reference(int&&) 输出右值引用。唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发(传递)了函数的实参给了内部调用的其他函数。
    std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值，std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看， std::forward(v) 和 static_cast<T&&>(v) 是完全一样的。


### RVO返回值优化


一种编译优化技术，清除了为保存函数返回值而创建的临时对象。


一般来说，C标准允许编译器执行任何优化，只要所得到的可执行文件表现出与标准的所有要求都已满足（即假装）一样的可观察行为（"假设as-if规则"）。RVO返回值优化则是C标准中的一个特殊条款，它甚至比 "as-if "规则更进一步：一个实现可以省略由返回语句产生的复制操作，即使复制构造函数有副作用。


```cpp
#include <iostream>

struct C {
  C() = default;
  C(const C&) { std::cout << "A copy was made.\n"; }
};

C f() {
  return C();
}

int main() {
  std::cout << "Hello World!\n";
  C obj = f();
}
```


根据编译器设置，输出可能有三种情况：


```
Hello World!
A copy was made.
A copy was made.


Hello World!
A copy was made.


Hello World!
```


## 容器


### 线性容器


1. std::array

    与std::vector相比，std::array有两个好处：
    - std::array 对象的大小是固定的，在已知数据容量的情况下使用array不用担心内存浪费、扩容耗时等操作
    - std::vector存入大量的数据后，如果对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 shrink_to_fit() 释放这部分内存，比较麻烦

    ```cpp
    std::vector<int> v;
    std::cout << "size:" << v.size() << std::endl;         // 输出 0
    std::cout << "capacity:" << v.capacity() << std::endl; // 输出 0

    // 如下可看出 std::vector 的存储是自动管理的，按需自动扩张
    // 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    std::cout << "size:" << v.size() << std::endl;         // 输出 3
    std::cout << "capacity:" << v.capacity() << std::endl; // 输出 4

    // 这里的自动扩张逻辑与 Golang 的 slice 很像
    v.push_back(4);
    v.push_back(5);
    std::cout << "size:" << v.size() << std::endl;         // 输出 5
    std::cout << "capacity:" << v.capacity() << std::endl; // 输出 8

    // 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还
    v.clear();                                             
    std::cout << "size:" << v.size() << std::endl;         // 输出 0
    std::cout << "capacity:" << v.capacity() << std::endl; // 输出 8

    // 额外内存可通过 shrink_to_fit() 调用返回给系统
    v.shrink_to_fit();
    std::cout << "size:" << v.size() << std::endl;         // 输出 0
    std::cout << "capacity:" << v.capacity() << std::endl; // 输出 0
    ```


    与传统数组相比，使用 std::array 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort：

    ```cpp
    std::array<int, 4> arr = {1, 2, 3, 4};

    arr.empty(); // 检查容器是否为空
    arr.size();  // 返回容纳的元素数

    // 迭代器支持
    for (auto &i : arr)
    {
        // ...
    }

    // 用 lambda 表达式排序
    std::sort(arr.begin(), arr.end(), [](int a, int b) {
        return b < a;
    });

    // 数组大小参数必须是常量表达式
    constexpr int len = 4;
    std::array<int, len> arr = {1, 2, 3, 4};

    // 非法,不同于 C 风格数组，std::array 不会自动退化成 T*
    // int *arr_p = arr;
    ```

2. std:forward_list

    std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进行介绍了。
    需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点）， 也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。



### 无序容器


无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。


C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。multi表示允许有重复key。


### 元组(tuple)


1. 元组基本操作

    关于元组的使用有三个核心的函数：
    - std::make_tuple: 构造元组
    - std::get: 获得元组某个位置的值
    - std::tie: 元组拆包
    
    ```cpp
    #include <tuple>
    #include <iostream>

    auto get_student(int id)
    {
        // 返回类型被推断为 std::tuple<double, char, std::string>

        if (id == 0)
            return std::make_tuple(3.8, 'A', "张三");
        if (id == 1)
            return std::make_tuple(2.9, 'C', "李四");
        if (id == 2)
            return std::make_tuple(1.7, 'D', "王五");
        return std::make_tuple(0.0, 'D', "null");
        // 如果只写 0 会出现推断错误, 编译失败
    }

    int main()
    {
        auto student = get_student(0);
        std::cout << "ID: 0, "
        << "GPA: " << std::get<0>(student) << ", "
        << "成绩: " << std::get<1>(student) << ", "
        << "姓名: " << std::get<2>(student) << '\n';

        double gpa;
        char grade;
        std::string name;

        // 元组进行拆包
        std::tie(gpa, grade, name) = get_student(1);
        std::cout << "ID: 1, "
        << "GPA: " << gpa << ", "
        << "成绩: " << grade << ", "
        << "姓名: " << name << '\n';
    }

    // C++14 增加了使用类型来获取元组中的对象
    std::tuple<std::string, double, double, int> t("123", 4.5, 6.7, 8);
    std::cout << std::get<std::string>(t) << std::endl;
    std::cout << std::get<double>(t) << std::endl; // 非法, 引发编译期错误
    std::cout << std::get<3>(t) << std::endl;
    ```

2. 运行期索引

    std::get<> 依赖一个编译期的常量，所以下面的方式是不合法的：

    ```cpp
    int index = 1;
    std::get<index>(t);
    ```

    那么要怎么处理？答案是，使用 std::variant<>（C++ 17 引入），提供给 variant<> 的类型模板参数 可以让一个 variant<> 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，表现为动态类型）：

    ```cpp
    #include <variant>

    template <size_t n, typename... T>
    constexpr std::variant<T...> _tuple_index(const std::tuple<T...>& tpl, size_t i) {
        if constexpr (n >= sizeof...(T))
            throw std::out_of_range("越界.");
        if (i == n)
            return std::variant<T...>{ std::in_place_index<n>, std::get<n>(tpl) };
        return _tuple_index<(n < sizeof...(T)-1 ? n+1 : 0)>(tpl, i);
    }

    template <typename... T>
    constexpr std::variant<T...> tuple_index(const std::tuple<T...>& tpl, size_t i) {
        return _tuple_index<0>(tpl, i);
    }

    template <typename T0, typename ... Ts>
    std::ostream & operator<< (std::ostream & s, std::variant<T0, Ts...> const & v) { 
        std::visit([&](auto && x){ s << x;}, v); 
        return s;
    }


    int i = 1;
    std::cout << tuple_index(t, i) << std::endl;
    ```

3. 元组合并与遍历

    合并两个元组，可以通过 std::tuple_cat 来实现：

    ```cpp
    auto new_tuple = std::tuple_cat(get_student(1), std::move(t));
    ```

    遍历一个元组：

    ```cpp
    template <typename T>
    auto tuple_len(T &tpl) {
        return std::tuple_size<T>::value;
    }

    // 迭代
    for(int i = 0; i != tuple_len(new_tuple); ++i)
        // 运行期索引
        std::cout << tuple_index(i, new_tuple) << std::endl;
    ```


## 智能指针与内存管理


### 引用计数


引用计数是为了防止内存泄露而产生的，基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。


在传统 C++ 中，“记得”手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。


而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。总体来说，智能指针模拟了一个具有普通指针功能的指针，还有一些更多的功能，如自动内存管理和边界检查，因此，它可以减少误用指针引起的错误。


### std::auto_ptr


std::auto_ptr管理一个通过新表达式获得的对象，并在std::auto_ptr被销毁时删除该对象。它为动态分配的对象提供了异常安全保护。不过std::auto_ptr有一些缺点，如拷贝时返回一个左值，不能调用delete[]等，因此在C++11中被废弃，（应该使用unique_ptr）


### std::shared_ptr


std::shared_ptr通过一个指针保留了一个对象的共享所有权，多个智能指针可以拥有同一个堆内存。std::shared_ptr能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示的调用 delete，当一个std::shared_ptr失效，内存也不会被释放，而是引用计数减小。当引用计数归零的时候std::shared_ptr才会真正释放堆内存的空间。


要使用 std::shared_ptr，常规办法是使用 new 来调用，但这使得代码出现了某种程度上的不对称。std::make_shared 就能够用来消除显式的使用 new，所以std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。


```cpp
#include <iostream>
#include <memory>
void foo(std::shared_ptr<int> i)
{
    (*i)++;
}
int main()
{
    // auto pointer = new int(10); // illegal, no direct assignment
    // Constructed a std::shared_ptr
    auto pointer = std::make_shared<int>(10);
    foo(pointer);
    std::cout << *pointer << std::endl; // 11
    // The shared_ptr will be destructed before leaving the scope
    return 0;
}
```


std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过use_count()来查看一个对象的引用计数。例如：


```cpp
auto pointer = std::make_shared<int>(10);
auto pointer2 = pointer; // 引用计数+1
auto pointer3 = pointer; // 引用计数+1
int *p = pointer.get(); // 这样不会增加引用计数
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 3
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 3
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 3

pointer2.reset();
std::cout << "reset pointer2:" << std::endl;
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 2
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 0, pointer2 已 reset
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 2
pointer3.reset();
std::cout << "reset pointer3:" << std::endl;
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl; // 1
std::cout << "pointer2.use_count() = " << pointer2.use_count() << std::endl; // 0
std::cout << "pointer3.use_count() = " << pointer3.use_count() << std::endl; // 0, pointer3 已 reset
```


### std::unique_ptr


std::unique_ptr是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全。std::unique_ptr管理一个只属于它的内存，并在std::unique_ptr被销毁或值改变时处理掉它。它不能被复制，可以被移动。


```cpp
#include <memory.h>

std::unique_ptr<int> pointer = std::make_unique<int>(10); // make_unique 从 C++14 引入
std::unique_ptr<int> pointer2 = pointer; // 非法
```


既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr，例如：


```cpp
std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p3 = std::move(p1); // move了，转移所有权，现在那块内存归p3所有，p1成为无效的指针
p3.reset(); //释放内存
p1.reset(); //实际上什么都没做
```


```cpp
#include <iostream>
#include <memory>

struct Foo {
    Foo() { std::cout << "Foo::Foo" << std::endl; }
    ~Foo() { std::cout << "Foo::~Foo" << std::endl; }
    void foo() { std::cout << "Foo::foo" << std::endl; }
};

void f(const Foo &) {
    std::cout << "f(const Foo&)" << std::endl;
}

int main() {
    std::unique_ptr<Foo> p1(std::make_unique<Foo>());
    // p1 不空, 输出
    if (p1) p1->foo();
    {
        std::unique_ptr<Foo> p2(std::move(p1));
        // p2 不空, 输出
        f(*p2);
        // p2 不空, 输出
        if(p2) p2->foo();
        // p1 为空, 无输出
        if(p1) p1->foo();
        p1 = std::move(p2);
        // p2 为空, 无输出
        if(p2) p2->foo();
        std::cout << "p2 被销毁" << std::endl;
    }
    // p1 不空, 输出
    if (p1) p1->foo();
    // Foo 的实例会在离开作用域时被销毁
}
```


### std::weak_ptr


如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。看下面这个例子，运行结果是 A, B 都不会被销毁，这是因为 a, b 内部的 pointer 同时又引用了 a, b，这使得 a, b 的引用计数均变为了 2，而离开作用域时，a, b 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 a, b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露。

![strong-ref.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/C++/strong-ref.png)

```cpp
struct A;
struct B;

struct A {
    std::shared_ptr<B> pointer;
    ~A() {
        std::cout << "A 被销毁" << std::endl;
    }
};
struct B {
    std::shared_ptr<A> pointer;
    ~B() {
        std::cout << "B 被销毁" << std::endl;
    }
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->pointer = b;
    b->pointer = a;
}
```


解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr是一种弱引用（不会引起引用计数增加，相比较而言 std::shared_ptr 就是一种强引用），指向一个std::shared_ptr，但它实际上不拥有这个内存。下图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。

![weak-ref.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/C++/weak-ref.png)

std::weak_ptr 没有 * 运算符和 -> 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true。其lock()方法可返回一个 std::shared_ptr，而当所指对象已经失效时，可以返回nullptr，用这个可以验证std::shared_ptr的有效性。


## 正则表达式


C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。


std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。例如：


```cpp
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string fnames[] = {"foo.txt", "bar.txt", "test", "a0.txt", "AAA.txt"};


    // [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多次， 因此 [a-z]+ 能够匹配一个小写字母组成的字符串。 在正则表达式中一个 . 表示匹配任意字符，而 \. 则表示匹配字符 .， 最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。

    // 在 C++ 中 \ 会被作为字符串内的转义符，为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.
    std::regex txt_regex("[a-z]+\\.txt");
    for (const auto &fname: fnames)
        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << std::endl;
}

// foo.txt: 1
// bar.txt: 1
// test: 0
// a0.txt: 0
// AAA.txt: 0
```


另一种常用的形式就是依次传入 std::string/std::smatch/std::regex 三个参数，其中 std::smatch 的本质其实是 std::match_results。在标准库中，std::smatch 被定义为了 std::match_results[std::string::const_iterator]()，也就是一个子串迭代器类型的 match_results。使用 std::smatch 可以方便的对匹配的结果进行获取，例如：


```cpp
std::regex base_regex("([a-z]+)\\.txt");
std::smatch base_match;
for(const auto &fname: fnames) {
    if (std::regex_match(fname, base_match, base_regex)) {
        // std::smatch 的第一个元素匹配整个字符串
        // std::smatch 的第二个元素匹配了第一个括号表达式
        if (base_match.size() == 2) {
            std::string base = base_match[1].str();
            std::cout << "sub-match[0]: " << base_match[0].str() << std::endl;
            std::cout << fname << " sub-match[1]: " << base << std::endl;
        }
    }
}

// sub-match[0]: foo.txt
// foo.txt sub-match[1]: foo
// sub-match[0]: bar.txt
// bar.txt sub-match[1]: bar
```


## 并行与并发


### 并行基础


std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含  头文件，它提供了很多基本的线程操作，例如 get_id() 来获取所创建线程的线程 ID，使用 join() 来加入一个线程等等：


```cpp
#include <iostream>
#include <thread>

int main() {
    std::thread t([](){
        std::cout << "hello world." << std::endl;
    });
    t.join();
    return 0;
}
```


### 互斥量与临界区


C++11 引入了 mutex 相关的类，其所有相关的函数都放在  头文件中。


std::mutex 是 C11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量， 而通过其成员函数 lock() 可以进行上锁，unlock() 可以进行解锁。 但是在在实际编写代码的过程中，最好不去直接调用成员函数， 因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。 这时候 C11 还为互斥量提供了一个 RAII 语法的模板类 std::lock_guard。 RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。


在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分。由于 C++ 保证了所有栈对象在声明周期结束时会被销毁，所以这样的代码也是异常安全的。无论 critical_section() 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 unlock()。


```cpp
#include <iostream>
#include <thread>

int v = 1;

void critical_section(int change_v) {
    static std::mutex mtx;
    std::lock_guard<std::mutex> lock(mtx);

    // 执行竞争操作
    v = change_v;

    // 离开此作用域后 mtx 会被释放
}

int main() {
    std::thread t1(critical_section, 2), t2(critical_section, 3);
    t1.join();
    t2.join();

    std::cout << v << std::endl;
    return 0;
}
```


std::unique_lock 则是相对于 std::lock_guard 出现的，std::unique_lock 更加灵活，std::unique_lock 的对象会以独占所有权（没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权）的方式管理 mutex 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 std::unique_lock。


std::lock_guard 不能显式的调用 lock 和 unlock，而 std::unique_lock 可以在声明后的任意位置调用，可以缩小锁的作用范围，提供更高的并发度：


```cpp
#include <iostream>
#include <thread>

int v = 1;

void critical_section(int change_v) {
    static std::mutex mtx;
    std::unique_lock<std::mutex> lock(mtx);
    // 执行竞争操作
    v = change_v;
    std::cout << v << std::endl;
    // 将锁进行释放
    lock.unlock();

    // 在此期间，任何人都可以抢夺 v 的持有权

    // 开始另一组竞争操作，再次加锁
    lock.lock();
    v += 1;
    std::cout << v << std::endl;
}

int main() {
    std::thread t1(critical_section, 2), t2(critical_section, 3);
    t1.join();
    t2.join();
    return 0;
}
```


另外，如果用到了条件变量 std::condition_variable::wait 则必须使用 std::unique_lock 作为参数。


### 期物(future)


期物（Future）表现为 std::future，它提供了一个访问异步操作结果的途径。


试想以下场景：我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。


在 C11 之前，通常的做法是：创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。而 C11 提供的 std::future 简化了这个流程。自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。具体而言，在封装好要调用的目标后，可以使用 get_future() 来获得一个 std::future 对象，以便之后实施线程同步：


```cpp
#include <iostream>
#include <future>
#include <thread>

int main() {
    // 将一个返回值为7的 lambda 表达式封装到 task 中
    // std::packaged_task 的模板参数为要封装函数的类型
    std::packaged_task<int()> task([](){return 7;});
    
    // 获得 task 的期物
    std::future<int> result = task.get_future(); // 在一个线程中执行 task
    std::thread(std::move(task)).detach();
    std::cout << "waiting...";
    result.wait(); // 在此设置屏障，阻塞到期物的完成
    
    // 输出执行结果
    std::cout << "done!" << std:: endl << "future result is " << result.get() << std::endl;
    return 0;
}
```


### 条件变量


条件变量 std::condition_variable 是为了解决死锁而生，当互斥操作不够用而引入的。它是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待某个条件为真，而将自己挂起；另一个线程使得条件成立，并通知等待的线程继续。


condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable的 notify_one() 用于唤醒一个线程； notify_all() 则是通知所有线程。


为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。参考以下代码段：


```cpp
#include <iostream>           // std::cout
#include <thread>             // std::thread
#include <mutex>              // std::mutex, std::unique_lock
#include <condition_variable> // std::condition_variable

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_id (int id) {
  std::unique_lock<std::mutex> lck(mtx); // lock the thread
  while (!ready) cv.wait(lck);
  // ...
  std::cout << "thread " << id << '\n';
}

void go() {
  std::unique_lock<std::mutex> lck(mtx);
  ready = true;
  cv.notify_all(); // wake up
}

int main ()
{
  std::thread threads[10];
  // spawn 10 threads:
  for (int i=0; i<10; ++i)
    threads[i] = std::thread(print_id,i);

  std::cout << "10 threads ready to race...\n";
  go();                       // go!

  for (auto& th : threads) th.join();

  return 0;
}
```


### 原子操作


在现代 CPU 体系结构下提供了 CPU 指令级的原子操作， 因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 std::atomic 模板，使得我们实例化一个原子类型，将一个原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：


```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<int> count = {0};

int main() {
    std::thread t1([](){
        count.fetch_add(1);
    });
    std::thread t2([](){
        count++;        // 等价于 fetch_add
        count += 1;     // 等价于 fetch_add
    });
    t1.join();
    t2.join();
    std::cout << count << std::endl;
    return 0;
}
```


当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于 CPU 的架构以及所实例化的类型结构是否满足该架构对内存对齐条件的要求，因而我们总是可以通过 std::atomic::is_lock_free 来检查该原子类型是否需支持原子操作。


为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了不同的内存顺序 std::memory_order 的选项，表达了四种多线程间的同步模型：


- 宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 std::memory_order_relaxed 指定

    ```cpp
    std::atomic<int> counter = {0};
    std::vector<std::thread> vt;
    for (int i = 0; i < 100; ++i) {
        vt.emplace_back([&](){
            counter.fetch_add(1, std::memory_order_relaxed);
        });
    }

    for (auto& t : vt) {
        t.join();
    }
    std::cout << "current counter:" << counter << std::endl;
    ```

- 释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 x 的写操作，线程 B 仅依赖其中第三次 x 的写操作，与 x 的前两次写行为无关，则当 A 主动 x.release() 时候（即使用 std::memory_order_release），选项 std::memory_order_consume 能够确保 B 在调用 x.load() 时候观察到 A 中第三次对 x 的写操作。

    ```cpp
    // 初始化为 nullptr 防止 consumer 线程从野指针进行读取
    std::atomic<int*> ptr(nullptr);
    int v;
    std::thread producer([&]() {
        int* p = new int(42);
        v = 1024;
        ptr.store(p, std::memory_order_release);
    });
    std::thread consumer([&]() {
        int* p;
        while(!(p = ptr.load(std::memory_order_consume)));

        std::cout << "p: " << *p << std::endl;
        std::cout << "v: " << v << std::endl;
    });
    producer.join();
    consumer.join();
    ```

- 释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 std::memory_order_release 和获取 std::memory_order_acquire 之间规定时序，即发生在释放操作之前的所有写操作，对其他线程的任何获取操作都是可见的，亦即发生顺序（happens-before）。

    ```cpp
    std::vector<int> v;
    std::atomic<int> flag = {0};
    std::thread release([&]() {
        v.push_back(42);
        flag.store(1, std::memory_order_release);
    });
    std::thread acqrel([&]() {
        int expected = 1; // must before compare_exchange_strong
        while(!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel)) {
            expected = 1; // must after compare_exchange_strong
        }
        // flag has changed to 2
    });
    std::thread acquire([&]() {
        while(flag.load(std::memory_order_acquire) < 2);

        std::cout << v.at(0) << std::endl; // must be 42
    });
    release.join();
    acqrel.join();
    acquire.join();
    ```

- 顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 std::memory_order_seq_cst 进行指定。

    ```cpp
    std::atomic<int> counter = {0};
    std::vector<std::thread> vt;
    for (int i = 0; i < 100; ++i) {
        vt.emplace_back([&](){
            counter.fetch_add(1, std::memory_order_seq_cst);
        });
    }

    for (auto& t : vt) {
        t.join();
    }
    std::cout << "current counter:" << counter << std::endl;
    ```


## 其他杂项


### 新类型：long long int


long long int 并不是 C11 最先引入的，其实早在 C99，long long int 就已经被纳入 C 标准中，所以大部分的编译器早已支持。C11 的工作则是正式把它纳入标准库，规定了一个 long long int 类型至少具备 64 位的比特数。


### noexcept的修饰与操作


C++11 将异常的声明简化为以下两种情况：


- 函数可能抛出任何异常
- 函数不能抛出任何异常



并使用 noexcept 对这两种行为进行限制，例如：


```cpp
void may_throw(); // 可能抛出异常
void no_throw() noexcept; // 不可能抛出异常


// 另一种用法：做操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false
#include <iostream>
void may_throw() {
    throw true;
}
auto non_block_throw = []{
    may_throw();
};
void no_throw() noexcept {
    return;
}

auto block_throw = []() noexcept {
    no_throw();
};
int main()
{
    std::cout << std::boolalpha
        << "may_throw() noexcept? " << noexcept(may_throw()) << std::endl
        << "no_throw() noexcept? " << noexcept(no_throw()) << std::endl
        << "lmay_throw() noexcept? " << noexcept(non_block_throw()) << std::endl
        << "lno_throw() noexcept? " << noexcept(block_throw()) << std::endl;
    return 0;
}
```


noexcept 修饰完一个函数之后能够起到封锁异常扩散的功效，如果内部产生异常，外部也不会触发。因为使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。


```cpp
try {
    may_throw();
} catch (...) {
    std::cout << "捕获异常, 来自 my_throw()" << std::endl;
}
try {
    non_block_throw();
} catch (...) {
    std::cout << "捕获异常, 来自 non_block_throw()" << std::endl;
}
try {
    block_throw();
} catch (...) {
    std::cout << "捕获异常, 来自 block_throw()" << std::endl;
}

// 捕获异常, 来自 my_throw()
// 捕获异常, 来自 non_block_throw()
```


### 字面量(Literals)


1. 原始字符串字面量

    字符串字面量，就是指这个量就如“字面上”一样，所见即所得。传统 C++ 里面要编写一个充满特殊字符的字符串其实是非常痛苦的一件事情，比如一个包含 HTML 本体的字符串需要添加大量的转义符，例如一个Windows 上的文件路径经常会变成这样：C:\File\To\Path。
    C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时，将原始字符串使用括号包裹：

    ```cpp
    std::cout << R"Hello\nWorld"; // 如“字面上”一样输出，不会对\n转义
    std::string str = R"(C:\File\To\Path)";
    ```

    用户还可以利用字符串字面量添加自定义后缀：
    
    ```cpp
    struct Test {
        unsigned long long int x;
    };

    Test operator "" _X(unsigned long long int t_x) {
        Test a;
        a.x = t_x;
        return a;
    }

    int main() {
        cout << (123_X).x;
    }
    ```

2. 自定义字面量

    C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现：

    ```cpp
    // 字符串字面量自定义必须设置如下的参数列表
    std::string operator"" _wow1(const char *wow1, size_t len) {
        return std::string(wow1)+"woooooooooow, amazing";
    }

    std::string operator"" _wow2 (unsigned long long i) {
        return std::to_string(i)+"woooooooooow, amazing";
    }

    int main() {
        auto str = "abc"_wow1;
        auto num = 1_wow2;
        std::cout << str << std::endl;
        std::cout << num << std::endl;
        return 0;
    }
    ```

    自定义字面量支持四种字面量：
    - 整型字面量：重载时必须使用 unsigned long long、const char *、模板字面量算符参数，在上面的代码中使用的是前者；
    - 浮点型字面量：重载时必须使用 long double、const char *、模板字面量算符；
    - 字符串字面量：必须使用 (const char *, size_t) 形式的参数表；
    - 字符字面量：参数只能是 char, wchar_t, char16_t, char32_t 这几种类型。



### 内存对齐


C++ 11 引入了两个新的关键字 alignof 和 alignas 来支持对内存对齐进行控制。


alignof 关键字能够获得一个与平台相关的 std::size_t 类型的值，用于查询该平台的对齐方式。当然我们有时候并不满足于此，甚至希望自定定义结构的对齐方式，于是C++ 11 还引入了 alignas 来重新修饰某个结构的对齐方式。


```cpp
#include <iostream>

struct Storage {
    char      a;
    int       b;
    double    c;
    long long d;
};

struct alignas(std::max_align_t) AlignasStorage {
    char      a;
    int       b;
    double    c;
    long long d;
};

int main() {
    std::cout << alignof(Storage) << std::endl;
    std::cout << alignof(AlignasStorage) << std::endl;
    return 0;
}
```


std::max_align_t 要求每个标量类型的对齐方式严格一样，因此它几乎是最大标量没有差异， 进而大部分平台上得到的结果为 long double，因此我们这里得到的 AlignasStorage 的对齐要求是 8 或 16。

# C++概念与对比

## 链接


链接分为内部链接和外部链接。


如果一个名称对于他的编译单元是局部的，并且在链接时不会与其他的编译单元中同样的名字冲突，那么这个名称就拥有内部链接。这个实体有内部链接，他就不会与其他.cpp文件同名的实体冲突。


那么哪些实体拥有内部链接？


1. 静态（static）全局变量，自由函数，友元函数定义
2. 类的定义
3. 内联函数定义
4. Union共用体定义
5. 名字空间的const常量定义
6. 枚举类型定义



一个多文件的程序中，一个实体可以在链接时与其他编译单元交互，那么这个实体就拥有外部链接。


1. 类的非内联函数（包括成员函数和静态类成员函数）的定义
2. 类的静态成员变量的定义
3. 命名空间或全局的非静态的自由函数，非静态变量，非友元函数的定义



有一些名字定义所表示的实体拥有外部链接，这样就意味着他可以跨越编译单元去进行代码的链接。所以，拥有外部链接的实体如果被声明在头文件并且被多个.cpp文件包含,可能就会出现链接冲突错误，因为每个包含这个拥有外部链接实体的.cpp都会分配空间，当多个编译单元链接的时候，连接器就会面对多个相同的名字，无法正常链接到正确的对象。


## 指针传递、值传递、引用传递


- 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作
- 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
- 引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都会通过栈中存放的地址访问主调函数中的实参变量。



```cpp
#include<iostream>
using namespace std;

//值传递
 void change1(int n){
    cout<<"值传递--函数操作地址"<<&n<<endl; //显示拷贝的地址而不是源地址 
    n++;
}

//引用传递
void change2(int & n){
    cout<<"引用传递--函数操作地址"<<&n<<endl; 
    n++;
}
 //指针传递
void change3(int *n){
     cout<<"指针传递--函数操作地址 "<<n<<endl; 
    *n=*n+1;
 } 
int main(){
    int n=10;
    cout<<"实参的地址"<<&n<<endl;
    change1(n);
    cout<<"after change1() n="<<n<<endl;
    change2(n);
    cout<<"after change2() n="<<n<<endl;
    change3(&n);
    cout<<"after change3() n="<<n<<endl;
    return true;
}

实参的地址0x7ffee9a7a9b8
值传递--函数操作地址0x7ffee9a7a96c
after change1() n=10
引用传递--函数操作地址0x7ffee9a7a9b8
after change2() n=11
指针传递--函数操作地址 0x7ffee9a7a9b8
after change3() n=12
```


## const与static


### const


**const的背景：**


C和C语言有一个很常见的预处理指令 `#define variablename variablevalue` 可以很方便地进行参数的调整与修改，增强代码可读性，提升程序的执行效率。然而预处理语句有个比较致命的缺点，即，只是简单进行值替代，缺乏类型的检测机制。这样预处理语句就不能享受C严格类型检查的好处，从而可能成为引发一系列错误的隐患。const推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。


**const的特点：**


1. 以const修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。
2. const避免意义模糊的数字出现，很方便地进行参数的调整和修改。
3. C++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的运行效率也很高
4. const定义也像一个普通的变量定义一样，编译器会对它进行类型的检测，消除了预定义语句的隐患。



**const的几种使用场景：**


1. const用于指针的两种情况分析

    ```cpp
    int const *a; 　//a可变，*a不可变
    int* const a; 　//a不可变，*a可变 



    char const *ptr; // non-constant pointer to a constant character; cannot change the value by pointer, by can change the pointer itself

    char* const ptr; // a constant pointer to non-constant character

    const char* const ptr; // a constant pointer to constant character
    ```

    分析：const是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，`int const` 限定 `*a`，不限定`a`；`int* const a` 限定`a`，不限定`*a`。
    如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。

2. const限定函数的传递值参数

    ```cpp
    void fun(const int var);
    ```

    分析：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。不过，更好的写法是在函数的内部进行限定，对外部调用者屏蔽，以免引起困惑。比如可改写如下：

    ```cpp
    void fun(int var) {
        const int & varalias = var;

        varalias ....

        .....
    }
    ```

3. 限定函数的值型返回值

    ```cpp
    const int fun1(); 

    const myclass fun2();
    ```

    分析：上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如fun1），已经是一个数值，当然不可被赋值更新，所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。

4. 常量普通对象/取地址对象

    此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。

5. const限定类的成员函数

    ```cpp
    class classname {
        public:

        int fun() const;

        .....

    }
    ```

    注意：采用此种const后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const，因为const已经成为类型信息的一部分。
    
    - 获得能力：可以操作常量对象。
    - 失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。



### static


**static的两大作用：**


1. 控制存储方式
引入static是为了告知编译器，将变量存储在程序的静态存储区而非栈空间内。
默认情况下，函数内部定义的变量，编译器为它在栈内分配空间，函数执行结束时栈空间也会被释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？
最容易想到的方法是定义一个全局的变量，但全局变量的缺点是破坏了此变量的访问范围，因此C++中引入了static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，又使得此变量的访问范围不变。
2. 控制可见性与链接类型
static还会把变量的可见范围限制在编译单元中，使它成为一个内部链接，这一点主要是针对全局变量而言。



**类中的static成员变量/成员函数：**


需求：


1. 需要在一个类的各个对象间交互，即需要一个数据对象为整个类而非某个对象服务。
2. 力求不破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。



类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。


注意：


- 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 `::` 来重新声明静态变量从而对它进行初始化
- 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数；普通成员函数则可以任意访问。



## 虚函数


### 虚函数 vs 纯虚函数


C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现，并且允许用基类的指针来调用子类的这个函数。子类可以重写父类的虚函数实现子类的特殊化。


```cpp
class A {
    public:

    virtual void out2(string s) {
        cout<<"A(out2):"<<s<<endl;
    }
};
```


C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。


C++中的纯虚函数也是一种“运行时多态”，但它更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。


```cpp
class A {
    public:
    virtual void out1(string s)=0;
    
};
```


### 动态绑定与虚函数表


- 虚表是一个指针数组，每个元素对应类中的一个虚函数的函数指针。


- 虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。

- 为了指定对象的虚表，每个对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，`__vptr`，用来指向虚表。


动态绑定：在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。引用（或指针）既可以指向基类对象也可以指向派生类对象。


虚函数表实现动态绑定：

![dynamic-binding.png](https://raw.githubusercontent.com/MikeYan01/mikeyan01.github.io/master/assets/images/C++/dynamic-binding.png)

- 类 A 包括两个虚函数，故 A vtbl 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
- 类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 B vtbl 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
- 类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 C vtbl 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。



最后，非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。


## 类的声明与构造


### 类声明后默认有哪些东西


```cpp
class Empty {
    public:
    Empty(); // 缺省构造函数

    Empty( const Empty& ); // 拷贝构造函数

    ~Empty(); // 析构函数

    Empty& operator=( const Empty& ); // 赋值运算符

    Empty* operator&(); // 取址运算符

    const Empty* operator&() const; // 取址运算符 const

};
```


注意，C++默认生成的函数，只有在被需要的时候，才会产生。即当我们定义一个类，而不创建类的对象时，就不会创建类的构造函数、析构函数等。


### 构造函数和析构函数


构造函数不能为虚函数，而析构函数可以且常常是虚函数。


**构造函数：**


1. 存储空间角度

    虚函数对应一个虚函数表vtable，这个vtable其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过vtable来调用，可是对象还没有实例化，也就是内存空间还无法找到vtable

2. 多态角度
　
    虚函数主要是用于实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。



**析构函数：**


析构函数的任务是释放内存，因此它必须确切知道被释放的对象的类型。


必须声明为虚函数的情况：基类指针指向子类对象的情况下，在基类销毁时，只会调用基类的析构函数，而不调用子类的析构函数，从而导致内存泄漏，所以需要虚函数机制来帮助系统识别需要释放哪些资源。


如果一个类是作为基类使用，那么他的虚构函数一定要是虚的；但是其子类或者子子类可以的析构函数可以是虚函数，也可以不是虚函数。


## 内存管理


### new vs malloc，delete vs free


总体而言：


- new和delete更好地适配了面向对象编程，也更加易于使用
- new和delete是C的运算符，而malloc和free是C和C的库函数，二者不能混用，尤其是在面向对象编程的场景下



**new和malloc的差别：**


1. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。那么new是否能在堆上动态分配内存？这取决于operator new的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。
2. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void _ ，需要通过强制类型转换将void_指针转换成我们需要的类型。
3. new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
4. 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
5. 使用new给对象分配内存时，会调用对象的构造函数，而free不会。具体来说：
   - 调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象
   - 编译器运行相应的构造函数以构造对象，并为其传入初值
   - 对象构造完成后，返回一个指向该对象的指针



**delete和free的区别**


1. free只是告诉操作系统回收某块内存，而delete会先调用类的析构函数，然后才告诉操作系统回收内存。具体来说：
   - 调用对象的析构函数
   - 编译器调用operator delete(或operator delete[])函数释放内存空间
2. 调用free的时候，传入指针的类型以及它所指的内存的容量事先都是知道的，因此可以直接free；但是delete不行，尤其是delete一个普通变量/数组时，要注意delete和delete []的差别，如果对数组回收内存时漏了括号，就只回收了数组首地址对应的内存，后面的对象都被遗漏了，造成内存泄漏



### 深拷贝浅拷贝


- 浅拷贝：增加了一个指针指向已经存在的内存
- 深拷贝：增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存



在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针或者引用时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以此时必须采用深拷贝。


深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，涉及到其他资源（如堆、文件、系统等）的指针或引用时，必须要用深拷贝。


## C++数据结构(STL)


### vector


在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，有两个概念，一个是实际的size()，表示vector内有几个元素；而capacity（）表示目前分配的内存最多能容纳多少个元素，当超过capacity会扩容；但是如果resize()大改小，capacity是不变的


### list


每一个结点都包括一个信息块Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。


### deque


功能上合并了vector和list，随机访问方便，即支持[ ]操作符和vector.at()，在内部方便的进行插入和删除操作，可在两端进行push、pop


deque由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。


### 两种map


unordered_map：基于哈希表
map：基于红黑树


### 两种set


unordered_set：基于哈希表
set：基于红黑树


## 模版


模板是泛型编程的基础，允许函数和类使用泛型进行操作，因此一个函数或类可以在许多不同的数据类型上工作，而不需要为每个类型重写。


```cpp
template <typename type> ret-type func-name(parameter list)
{
   // 函数的主体
}
```


type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。


```cpp
template <typename T>
inline T const& Max (T const& a, T const& b) { 
    return a < b ? b:a; 
}
```
